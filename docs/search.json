[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Quant a…",
    "section": "",
    "text": "Aquest és el meu bloc personal, on trobaràs informació diversa que he anat recopilant i/o investigant sobre diferents aspectes del desenvolupament d’aplicacions, l’administració de sistemes o electrònica digital, …\nNo és tant un faristol o aparador personal, sinó una referència personal que comparteixo amb la resta del món, si és que el món vol i hi és interessat. I si és així, millor, sense més.\nAquest espai ha estat configurat amb el generador estàtic de blocs anomenat Quarto.\nPots posar-te en contacte amb mi per tot un grapat de canals. Busca les iconetes de la pàgina, que trobaràs alguns canals… i si m’intentes contactar i no et responc, no és res personal, és que vaig cardat de temps!\nSalut!"
  },
  {
    "objectID": "posts/2013-05-10-BD00-curs-bbdd-i-java/index.html#temari-i-distribució-horària",
    "href": "posts/2013-05-10-BD00-curs-bbdd-i-java/index.html#temari-i-distribució-horària",
    "title": "Curs BBDD i Java (índex)",
    "section": "Temari i distribució horària",
    "text": "Temari i distribució horària\nDIA 1: Introducció i conceptes bàsics (4h)\n\nTipus de BD: discusió i ús i aproximació als punts clau del curs\nBD relacionals (MySQL + Java): JDBC amb SQL\nBD objecte-relacionals: Oracle\nBD natives XML (arxius XML): StaX i JAXB\n\nDIA 2: Hibernate i persistència (4h)\n\nBD relacionals (MySQL + Java): Hibernate\nBD relacionals (MySQL + Java): Hibernate/JPA\n\nDIA 3: BDOO (4h)\n\nBD orientades a objecte (db4o + Java)\n\nDIA 4: XND (4h)\n\nBD natives XML (BaseX + Java): XND: XPath/XQuery\nBD natives XML (BaseX + Java): API Java",
    "crumbs": [
      "Inici",
      "Curs BDDD (índex)"
    ]
  },
  {
    "objectID": "posts/2013-05-10-BD00-curs-bbdd-i-java/index.html#arxius-del-curs",
    "href": "posts/2013-05-10-BD00-curs-bbdd-i-java/index.html#arxius-del-curs",
    "title": "Curs BBDD i Java (índex)",
    "section": "Arxius del curs",
    "text": "Arxius del curs\n\nSessió número 1 (JDBC, StaX i JAXB): curset_dia1.zip\nSessió número 2 (Hibernate, JPA): curset_dia2.zip\nSessió número 3 (db4o): curset_dia3.zip\nSessió número 4 (BaseX, XPath/XQuery): curset_dia4.zip",
    "crumbs": [
      "Inici",
      "Curs BDDD (índex)"
    ]
  },
  {
    "objectID": "posts/2013-05-10-BD00-curs-bbdd-i-java/index.html#recursos-externs",
    "href": "posts/2013-05-10-BD00-curs-bbdd-i-java/index.html#recursos-externs",
    "title": "Curs BBDD i Java (índex)",
    "section": "Recursos externs",
    "text": "Recursos externs\nGeneral:\n\nBruce Eckel, Thinking in Java, Ed. Prentice Hall, 2000, ISBN: 0-13-027363-5\nDiversos autors, Aprenda Java como si estuviera en primero, Escuela Superior de Ingenieros Industriales, Universitat de Navarra, 2000: http://www.tecnun.es/asignaturas/Informat1/AyudaInf/aprendainf/Java/Java2.pdf\n\nSobre bases de dades, tipus de bases de dades i classificacions\n\nConcepte de OODBMS: http://en.wikipedia.org/wiki/Object_database\nFonaments de OODBMS: ODL, OML, OCL: http://www.xtec.cat/~iguixa/materialsGenerics/USAL_BDOO_MATISSE.pdf\n\nSobre JDBC:\n\nThe Java Tutorials: JDBC Basics: http://docs.oracle.com/javase/tutorial/jdbc/basics/index.html\n\nSobre patrons de disseny i DAO:\n\nDAO: http://en.wikipedia.org/wiki/Data_access_object\nData Access object (DAO) Design Pattern: http://www.roseindia.net/tutorial/java/jdbc/dataaccessobjectdesignpattern.html\nCore J2EE Patterns - Data Access Object: http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html\n\nSobre ORDBMS amb Oracle:\n\nIntroduction to Oracle Objects: http://docs.oracle.com/cd/B28359_01/appdev.111/b28371/adobjint.htm\nObject Support in Oracle Programming Environments: http://docs.oracle.com/cd/B28359_01/appdev.111/b28371/adobjenv.htm\n\nSobre XML, JAXB i StaX:\n\nLars Vogel, Java and XML - Tutorial: http://www.vogella.com/articles/JavaXML/article.html\nLars Vogel, JAXB Tutorial: http://www.vogella.com/articles/JAXB/article.html\n\nSobre Hibernate, JPA, HQL, JPQL i CriteriaQuery:\n\nHibernate (Tutorial oficial): http://www.jboss.org/jdf/examples/ticket-monster/tutorial/DataPersistence\n\nSobre OODBMS:\n\nTutorial oficial de db4o: http://community.versant.com/Documentation/Reference/db4o-8.0/java/tutorial/\n\nSobre XND:\n\nExemples Java de BaseX: http://docs.basex.org/wiki/Java_Examples\nEspecificació de XQuery 3.0: http://www.w3.org/TR/xquery-30/\nTutorial de XQuery: http://www.w3schools.com/xquery/default.asp\nFuncions XPath: http://www.w3.org/TR/xpath-functions-30/\nFuncions XQuery: http://www.xqueryfunctions.com",
    "crumbs": [
      "Inici",
      "Curs BDDD (índex)"
    ]
  },
  {
    "objectID": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html",
    "href": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html",
    "title": "Arguments i modificadors en shell-scripts",
    "section": "",
    "text": "Un bon shell-script, o si més no aquell que incorpori unes quantes variacions del seu objectiu original, haurà de presentar diversos switch (modificadors).\nAlguns d’aquests modificadors potser necessiten un valor o dada que els acompanyi (número de línies, color, longitud, ruta d’arxiu, etc.).\nFins i tot voldrem que els modificadors presentin diversos noms alternatius. Normalment una variant curta per als més comuns o utilitzats. Per exemple, si hem de definir un modificador de color, potser triarem el nom llarg --color, i per al cas curt una simple -c ja ens bastaria.\nEl shell-script potser també rebrà arguments convencionals, que no venen donats o emmarcats en un modificador, sinó que seran posicionals. Per exemple, si el programa sempre rep el nom d’un arxiu com a únic argument."
  },
  {
    "objectID": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html#requeriments",
    "href": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html#requeriments",
    "title": "Arguments i modificadors en shell-scripts",
    "section": "",
    "text": "Un bon shell-script, o si més no aquell que incorpori unes quantes variacions del seu objectiu original, haurà de presentar diversos switch (modificadors).\nAlguns d’aquests modificadors potser necessiten un valor o dada que els acompanyi (número de línies, color, longitud, ruta d’arxiu, etc.).\nFins i tot voldrem que els modificadors presentin diversos noms alternatius. Normalment una variant curta per als més comuns o utilitzats. Per exemple, si hem de definir un modificador de color, potser triarem el nom llarg --color, i per al cas curt una simple -c ja ens bastaria.\nEl shell-script potser també rebrà arguments convencionals, que no venen donats o emmarcats en un modificador, sinó que seran posicionals. Per exemple, si el programa sempre rep el nom d’un arxiu com a únic argument."
  },
  {
    "objectID": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html#cas-bàsic--h---help",
    "href": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html#cas-bàsic--h---help",
    "title": "Arguments i modificadors en shell-scripts",
    "section": "Cas bàsic -h, --help",
    "text": "Cas bàsic -h, --help\nEvidentment la forma d’implementar aquest cas és simple, podríem mirar el valor del primer argument i comparar-lo manualment amb les cadenes corresponents a aquests modificadors. Si hi són, mostrem l’ajuda. Si no hi són, el programa no els ha rebut i podem executar la seva funció principal:\n\n\nexample1.sh\n\n#!/bin/bash\nfunction showHelp() {\n  PROGNAME=`basename $0`\n  echo \"Usage: $PROGNAME [-h|--help]\"\n  # ... echo more help text\n}\n\nif [ \"$1\" == \"-h\" -o \"$1\" == \"--help\" ]\nthen\n  showHelp\n  exit 0\nfi\n\n# Rest of the script...\n\nAquesta implementació la deixaria només per al cas en què:\n\nEl programa NO rep cap argument d’entrada (executa un procés fix, com un backup o una neteja d’arxius)\nNomés volem donar un ÚNIC modificador d’ajuda que ens “recordi” què fa el programa i què esperar d’ell\n\nI és que en el cas de diversos modificadors amb o sense dada, caldria programar un analitzador que comprovi els següents casos:\n\nSense modificador: programa\nAmb modificador : programa --color red\nAmb modificador curt : programa -c red\nAmb el modificador mal escrit : programa --color o programa -c\nAmb el modificador d’ajuda: programa -h o programa --help\nAmb el modificador i un argument posicional: programa -c red \"Hello\"\nNomés l’argument posicional: programa \"Hello\"\n…\n\nCom es pot veure les opcions es disparen, sense pensar en el cas que s’hagi intentat escriure un modificador inexistent, que existeixin diversos modificadors que es puguin donar en qualsevol ordre, etc… I tot només mirant $1, $2, … Una barbaritat!"
  },
  {
    "objectID": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html#getopts-al-rescat",
    "href": "posts/2021-04-01-arguments-i-modificadors-en-shell-scripts/index.html#getopts-al-rescat",
    "title": "Arguments i modificadors en shell-scripts",
    "section": "getopts al rescat!",
    "text": "getopts al rescat!\nLa utilitat getopts normalment la trobarem com a shell built-in, és a dir, com a comanda integrada dins de la mateixa shell i no com a programa extern. Algunes implementacions de shell poden requerir que s’instal·li separadament, però ve integrada en la majoria de shells modernes.\nAquesta utilitat ens permet analitzar fàcilment els modificadors, quan aquests són d’un sol caràcter (modificadors curts), i normalment la trobem en blocs de codi com aquest:\n\n\nexample2.sh\n\n#!/bin/bash\nfunction showHelp() {\n    PROGNAME=`basename $0`\n    echo \"Usage: $PROGNAME [-h] [-v] [-c color]\"\n    # echo more help\n}\n\nCOLOR=transparent\nVERBOSITY=0\nwhile getopts \"hvc:\" opt\ndo\n  case $opt in\n    h)\tshowHelp; exit;;\n    v)  VERBOSITY=1;;\n    c)\tCOLOR=\"$OPTARG\";;\n    ?)\tshowHelp;\n        exit 2;;\n  esac\ndone\n\necho \"Verbosity level: $VERBOSITY\"\necho \"Requested color: $COLOR\"\nshift $(($OPTIND - 1))\necho \"Remaining arguments are: $*\"\n\n# Here goes more code...\n\nAquest programa tal i com està ara mateix ens permetrà executar-lo de les següents maneres:\nprograma -h\nprograma -v\nprograma -c red\nprograma -c red image.png\nprograma -v -c red image.png\nprograma -vc red image.png\nÉs a dir, que ens acceptarà qualsevol de les combinacions habituals a què estem acostumats en programes i scripts de Linux, amb opcions curtes que podem escriure juntes (-vc red és equivalent a -v -c red). El programa mostrat també accepta arguments addicionals, que seran posicionals ($1, $2, …) i que seran la resta que quedi després de treure les opcions.\nPerò com és que funciona així? Què són OPTARG i OPTIND? Què representa la línia del while? Analitzem com funciona:\n\ngetopts permet l’execució while tal i com es mostra, rebent dos arguments: una cadena que especifica les opcions curtes que volem analitzar i el nom d’una variable de shell que és on es guardarà l’opció “descoberta”.\nEn cada iteració del while la variable opt (el nom es podria canviar si es desitgés) valdrà un dels modificadors passats per l’usuari al programa, per això hem fet un case per analitzar quin dels modificadors és i fer l’acció que correspongui.\nEl primer argument de getopts conté els modificadors permesos, tots seguits. Com que volem els modificadors -h, -v i -c, els indiquem seguits. El signe de : indica que el modificador anterior (en aquest cas la c) rebrà un argument. Això vol dir que podríem haver escrit la cadena de modificadors com s’ha fet (hvc:) o en un altre ordre (c:hv, hc:v o vc:h, per exemple). L’important és que el dos punts sempre segueixi la c, per indicar que aquest modificador requereix d’un argument.\nQuan un modificador té argument (indicat pel signe : en la cadena de modificadors de getopts), disposarem d’aquest argument en la variable d’entorn OPTARGS. Per això veieu que s’extreu el color mitjançant aquesta variable. getopts s’encarrega de gestionar-la.\nL’altra variable que getopts gestiona per nosaltres és OPTIND, que és un índex que apunta al següent argument passat al programa que s’haurà d’analitzar. Així podem saber en quin punt exacte de la llista d’arguments està analitzant en tot moment.\nUsem OPTIND per “saltar” fins a ell i eliminar així tots els modificadors i valors indicats i quedar-nos amb la resta d’arguments del programa, que correspondran als arguments posicionals clàssics (el nom de l’arxiu a processar, el directori on fer l’operació, la cadena de text a tractar, etc.)."
  },
  {
    "objectID": "posts/2012-07-19-oracle-sql-es-facil/index.html",
    "href": "posts/2012-07-19-oracle-sql-es-facil/index.html",
    "title": "Oracle SQL és fàcil!",
    "section": "",
    "text": "Portada del llibre\n\n\n\n\n\nOracle SQL és fàcil!\nManual i exemples d’Oracle SQL per a Oracle 10g/11g\nISBN: 978-84-615-9841-0\nPublicat: Juliol del 2012\nVeure índex Més info"
  },
  {
    "objectID": "posts/2012-07-19-oracle-sql-es-facil/index.html#arxius-associats-al-llibre",
    "href": "posts/2012-07-19-oracle-sql-es-facil/index.html#arxius-associats-al-llibre",
    "title": "Oracle SQL és fàcil!",
    "section": "Arxius associats al llibre",
    "text": "Arxius associats al llibre\nPot descarregar els arxius de base de dades associats al llibre amb l’arxiu ZIP següent: Arxiu ZIP de contingut"
  },
  {
    "objectID": "posts/2012-07-19-oracle-sql-es-facil/index.html#errades-i-comentaris",
    "href": "posts/2012-07-19-oracle-sql-es-facil/index.html#errades-i-comentaris",
    "title": "Oracle SQL és fàcil!",
    "section": "Errades i comentaris",
    "text": "Errades i comentaris\nEncara no s’ha detectat cap errada important…"
  },
  {
    "objectID": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html",
    "href": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html",
    "title": "Liquid-LaTeX Jekyll Plugin",
    "section": "",
    "text": "I’ve just finished my second Jekyll plugin: the jekyll-liquid-latex-plugin. This plugin for the Jekyll blogging software extends the rendering system allowing you to render \\(\\LaTeX\\) pieces of code inside your post. The result will be an image placed instead of the block of \\(\\LaTeX\\) code, so you don’t need to access any other software tool to compile \\(\\LaTeX\\) inside your posts."
  },
  {
    "objectID": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#the-plugin",
    "href": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#the-plugin",
    "title": "Liquid-LaTeX Jekyll Plugin",
    "section": "The plugin",
    "text": "The plugin\nYou can access it’s source code, clone it and/or use it from Gitlab: https://gitlab.com/felix.galindo/jekyll-liquid-latex-plugin\nThis plugin is able to render \\(\\LaTeX\\) block code as if you have a complete \\(\\LaTeX\\) document. Instead of a full DVI, EPS, or PDF file, this plugin renders the \\(\\LaTeX\\) block to PNG and inserts an &lt;img&gt; tag instead.\nThis, simply put, allows you to write this inside any of your posts:\n{% latex %}\n\\begin{eqnarray*}\n(A\\cup B)-(C-A) &=& (A\\cup B) \\cap (C-A)^c\\\\\n&=& (A\\cup B) \\cap (C \\cap A^c)^c \\\\\n&=& (A\\cup B) \\cap (C^c \\cup A) \\\\\n&=& A \\cup (B\\cap C^c) \\\\\n&=& A \\cup (B-C)\n\\end{eqnarray*}\n{% endlatex %}\nAnd you’ll get:\n\\[\n\\begin{eqnarray*}\n(A\\cup B)-(C-A) &=& (A\\cup B) \\cap (C-A)^c\\\\\n&=& (A\\cup B) \\cap (C \\cap A^c)^c \\\\\n&=& (A\\cup B) \\cap (C^c \\cup A) \\\\\n&=& A \\cup (B\\cap C^c) \\\\\n&=& A \\cup (B-C)\n\\end{eqnarray*}\n\\]\nAnother example:\n{% latex density=72 %}\n\\begin{picture}(100,100)(0,0)\n\\setlength{\\unitlength}{1pt}\n\\put(20,70){\\circle{30}}  \\put(20,70){\\circle*{10}}   % left eye\n\\put(80,70){\\circle{30}}  \\put(80,70){\\circle*{10}}   % right eye\n\\put(40,40){\\line(1,2){10}} \\put(60,40){\\line(-1,2){10}} \\put(40,40){\\line(1,0){20}} % nose\n\\put(50,20){\\oval(80,10)[b]} % mouth\n\\multiput(0,90)(4,0){10}{\\line(1,3){4}}  % left eyebrow\n\\multiput(100,90)(-4,0){10}{\\line(-1,3){4}}  % right eyebrow\n\\end{picture}\n{% endlatex %}\nAnd get this:\n \nAnother example, you write in your post:\n{% latex density=100 usepackages=sudoku %}\n\\begin{sudoku}\n| |2| | |3| |9| |7|.\n| |1| | | | | | | |.\n|4| |7| | | |2| |8|.\n| | |5|2| | | |9| |.\n| | | |1|8| |7| | |.\n| |4| | | |3| | | |.\n| | | | |6| | |7|1|.\n| |7| | | | | | | |.\n|9| |3| |2| |6| |5|.\n\\end{sudoku}\n{% endlatex %}\nThe result will be this:\n \nAs you can see, this last example depends on the sudoku package to be installed in your system. If you are using TeXLive, you must install it if it’s not already there:\nsudo tlmgr install sudoku"
  },
  {
    "objectID": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#installation",
    "href": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#installation",
    "title": "Liquid-LaTeX Jekyll Plugin",
    "section": "Installation",
    "text": "Installation\nJust copy the liquid_latex.rb file to the _plugins folder."
  },
  {
    "objectID": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#requirements",
    "href": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#requirements",
    "title": "Liquid-LaTeX Jekyll Plugin",
    "section": "Requirements",
    "text": "Requirements\nObviously you must have a LaTeX installation of some kind (like TeXLive) and some additional software capable of transforming a EPS file to its corresponding PNG equivalent (like ImageMagick)."
  },
  {
    "objectID": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#configuration",
    "href": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#configuration",
    "title": "Liquid-LaTeX Jekyll Plugin",
    "section": "Configuration",
    "text": "Configuration\nThere are several configuration parameters that you can define in your _config.yml. Here is a sample of such items:\n# ...\n# ... your _config.yml file ...\n# ...\n\n# Liquid-LaTeX plugin\nliquid_latex:\n    debug: false\n    density: 300\n    usepackages: pst-all,pst-3dplot\n    output_directory: /res/latex\n    latex_cmd: \"latex -interaction=nonstopmode $texfile &&gt; /dev/null\"\n    dvips_cmd: \"dvips -E $dvifile -o $epsfile &&gt; /dev/null\"\n    convert_cmd: \"convert -density $density $epsfile $pngfile &&gt; /dev/null\"\n    temp_filename: \"latex_temp\"\nAn explanation of those parameters follows:\n_config.xml parameters for this plugin:\n\n\n\n\n\n\n\n\nParameter\nType\nValue\n\n\n\n\ndebug\nboolean\nActivates the debug mode with which you can see the compilation commands that are executed during build. Default value: false\n\n\ndensity\nnumeric\nDensity for the conversion of PostScript (EPS) to PNG. Default value:300\n\n\nusepackages\nstring\nName of the packages (as a list of comma-separated) that will be passed globally to each block of \\(\\LaTeX\\) code. They will be added individually to their corresponding \\usepackage{...} lines in the temporary \\(\\LaTeX\\) file. Default value: empty string (no packages)\n\n\noutput_directory\nstring\nPath in which the generated PNG will be placed. Default value: /latex\n\n\ntemp_filename\nstring\nName of the temporary file that will be generated for the compilation process. Default value: latex_temp\n\n\nlatex_cmd\nstring\nCommand line to execute for the .tex to .div conversion. Default value: latex -interaction=nonstopmode $texfile &&gt; /dev/null\n\n\ndvips_cmd\nstring\nCommand line to execute for the .dvi to .eps conversion. Default value: dvips -E $dvifile -o $epsfile &&gt; /dev/null\n\n\nconvert_cmd\nstring\nCommand line to execute for the .eps to .png conversion. Default value: convert -density $density $epsfile $pngfile &&gt; /dev/null\n\n\n\nIn these last three parameters you can use the following variables:\nSubstitution variables for the command line configurations:\n\n\n\nVariable\nValue\n\n\n\n\n$texfile\nName of the LaTeX temporary file\n\n\n$dvifile\nName of the DVI temporary file\n\n\n$epsfile\nName of the EPS temporary file\n\n\n$pngfile\nName of the generated PNG file\n\n\n$density\nDensity value that will be used by the conversion\n\n\n\nThis variables makes you able to choose which software you use for the whole conversion process. The sample shown above, as well as the default parameters, where defined for use with TeXLive and ImageMagick.\nIf you don’t use a certain parameter, it will take the default value. If you are happy with all the default values you can omit the whole liquid-latex section in your _config.xml."
  },
  {
    "objectID": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#notes",
    "href": "posts/2013-11-10-liquid-latex-jekyll-plugin/index.html#notes",
    "title": "Liquid-LaTeX Jekyll Plugin",
    "section": "Notes",
    "text": "Notes\n\nThe plugin doesn’t recompile a previously rendered block of \\(\\LaTeX\\). It takes into consideration a change in the text or a change in the arguments (density and packages used). This reduces the total time of the building process.\nAside, you can delete all the contents of your \\(\\LaTeX\\) generated blocks in the source directory if you want to make a backup copy of your site. It will be completelly regenerated when you rebuild your site.\nAlso, this plugin keeps the folder of generated images in a clean state. That is, there will be only those images that are used in your site. All previously generated images will be deleted if they are detected as orphaned from the posts.\nIf you are trying to generate a picture with PSTricks, I recommend to insert the PSTricks code inside a TeXtoEPS environment. This ensures a perfect crop of the generated image.\nFor example:\n{% latex density=72 usepackages=pst-all,pst-eps %}\n\\begin{TeXtoEPS}\n\\begin{pspicture}(0,0)(7,2)\n\\psframe(0,0)(7,2) \\psline(0,0)(7,2) \\psline(7,0)(0,2)\n\\end{pspicture}\n\\end{TeXtoEPS}\n{% endlatex %}"
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#el-led",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#el-led",
    "title": "Elements de sortida electrònics (I)",
    "section": "El LED",
    "text": "El LED\nSense entrar en consideracions físiques o electròniques sobre el silici i els diferents dopants que fan possible l’existència dels LEDs, tots sabem que n’existeixen de diferents mides i colors. Podem trobar actualment fins i tot aquells que tenen la possibilitat de mostrar-nos més d’un color (bi-color, tri-color), o fins i tot els LEDs RGB, que permeten la construcció de qualsevol color activant independentment cadascun dels tres colors bàsics (vermell, verd i blau) a diferents nivells d’intensitat.\nPer al nostre estudi inicial considerarem només els LEDs d’un sol color, els tradicionals. Pensi’s, per tant, en el típic LED de color vermell, de 5mm de diàmetre.\n\n\n\nLED vermell de 5mm\n\n\nAquests LEDs tenen, com a característica principal, que amb només 10mA de corrent al seu través i un mínim d’entre 1.7V i 2.2V entre els seus terminals, ja donen prou llum com per a considerar-los plenament encesos.\nPer tant, el mecanisme de càlcul és senzill:\n\nHem d’assegurar-nos que la tensió disponible és superior als 1.7V – 2.2V\nLa intensitat de llum generada és proporcional al corrent que passa al seu través\nSi tenim més de 1.7V – 2.2V, hem de col·locar una resistència limitadora que es quedi amb la resta de tensió; aprofitant-la, de retruc, per a fixar el corrent que passarà a través del LED\n\nAmb tot el que s’ha dit, assumeixi’s el circuit de la figura següent:\n\n\n\nCircuit senzill amb LED\n\n\nEn aquesta simulació de Proteus pot veure’s com, amb una alimentació de 5V, una resistència de 220Ω fa que el corrent que passa a través del LED sigui d’aproximadament 14mA. En la majoria de casos, aquest nivell de brillantor és més que suficient.\nEl càlcul involucrat és el següent:\n\nSuposem que volem encendre el LED amb 15mA de corrent (nivell de llum intens, però no extrem)\nConsiderem que el LED treballa a 1.7V\n\nAleshores,\n\\[  R=\\frac{5-1.7}{0.015}=220\\Omega \\]\nAixí es fa per trobar la resistència adequada per a cada cas de tensió i corrent desitjats.\nEl valor més habitual de resistència limitadora és de 220Ω o 330Ω, per a una alimentació a 5V. A vegades 470Ω per a il·luminació suau:\n\nAmb R=220Ω: \\[I=\\frac{5-1.7}{220}=15\\textrm{mA}\\]\nAmb R=330Ω: \\[I=\\frac{5-1.7}{330}=10\\textrm{mA}\\]\nAmb R=470Ω: \\[I=\\frac{5-1.7}{470}=7\\textrm{mA}\\]\n\nTambé podem posar el LED a la part superior, i deixar la resistència a sota. És a dir, intercanviant els papers de resistència i LED.\nEls circuits de lògica digital, els microprocessadors i altres components d’altes prestacions, lliuren un “0” o un “1” lògics, que queden codificats amb una tensió baixa i una tensió alta, respectivament.\nPodem aprofitar el cas de sortida “1” per encendre un LED, connectant-lo al zero a través d’una resistència, com abans. Si el terminal treu un “0”, el LED romandrà apagat.\nPerò també podem aprofitar el cas de sortida a “0” per a encendre el LED, ara connectant-lo a través d’una resistència al positiu de l’alimentació. El terminal treurà un “0” lògic, que serà una tensió baixa, i el LED s’encendrà. Si el terminal treu un “1”, el LED romandrà apagat.\nEls valors concrets amb què això succeeix poden variar, considerant que el nivell mínim d’operació d’un transistor és de 0.6V. Això comporta que, habitualment, el “0” queda codificat amb un nivell baix de 0.6V aproximadament; mentre que el “1”, nivell alt, és d’uns 4V.\nAixò permet que, de fet, els circuits lògics podem actuar directament sobre un LED, sempre i quan el circuit integrat determinat tingui prou corrent disponible a les seves sortides. Això sempre s’ha de comprovar prèviament, perquè podria fer malbé el dispositiu, sobretot en el cas de microprocessadors d’alta capacitat quant a càlcul i velocitats.\nEls paràmetres per a aquesta comprovació són:\n\nEl corrent màxim permès per terminal de sortida, considerant el corrent sortint (LED encès amb “1” lògic). Normalment anomenat \\(I_{OH,max}\\), o sota la terminologia “Max. current (source)”\nEl corrent màxim permès per terminal de sortida, considerant el corrent entrant (LED encès amb “0” lògic). Normalment anomenat \\(I_{OL,max}\\), o sota la terminologia “Max. current (sink)”\nEl màxim de corrent sortint global de tot el dispositiu (la suma de tots els corrents sortints de tots els terminals): Alguns dispositius tenen un màxim global per qüestions de dissipació de calor\nEl màxim de corrent entrant global de tot el dispositiu (la suma de tots els corrents entrants de tots els terminals)\n\nNo obstant això, la majoria de circuits integrats permetran els 10mA necessaris per a il·luminar un LED en algun terminal de sortida. I, de fet, uns quants LEDs situats en diferents terminals. Observi’s la figura següent:\n\n\n\nCircuit amb diversos LEDs\n\n\nEn aquest cas s’ha considerat que, si el microprocessador lliura un “1” lògic per un terminal determinat dels utilitzats (RA0, RA1, RA2 o RA3), aleshores el LED corresponent s’encendrà.\nPodem commutar la polaritat dels LEDs i connectar al positiu, redreçant el circuit tal i com es mostra a la figura següent:\n\n\n\nCircuit amb diversos LEDs, per a nivell baix\n\n\nEn aquest cas, per encendre un LED s’haurà de treure un “0” lògic pel terminal corresponent."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#la-barra-de-leds",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#la-barra-de-leds",
    "title": "Elements de sortida electrònics (I)",
    "section": "La barra de LEDs",
    "text": "La barra de LEDs\nAls circuits on es necessiti un nombre elevat de LEDs, o si volem construir un indicador de nivell amb LEDs (un termòmetre, per exemple), podem fer servir les barres de LEDs.\n\n\n\nArray de LEDs\n\n\nAquests elements disposen d’un determinat nombre de LEDs en un encapsulat únic (típicament 10), cosa que millora el disseny del circuit físic, permetent reduir la seva mida.\nTípicament poden trobar-se de colors vermell o verd en configuracions de 10 LEDs.\nEl tipus d’encapsulat (footprint) és el mateix que el d’un circuit integrat de 20 terminals (10 a cada banda), si és un array de 10 LEDs. Per tant, podria col·locar-se amb un sòcol DIL20.\nEn aquest punt és interessant notar l’existència dels arrays de resistències fixes; que, a diferència de la barra de LEDs, en aquest cas es disposa d’un dels dos terminals de les resistències en forma compartida.\n\n\n\nArray de resistències fixes\n\n\nAquests grups de resistències, combinats amb els arrays de LEDs, permeten una reducció molt important de l’espai necessari per als senyalitzadors del nostre circuit.\nQuant a les consideracions tècniques referents a tensions i corrents, els paràmetres dels arrays de LEDs solen ser semblants als dels LEDs individuals; de manera que requerirem, novament, resistències limitadores de corrent de valors similars als anteriors.\nLes caigudes de tensió necessàries per a fer-los funcionar són les habituals, d’entre 1.7V i 2.2V, segons el tipus de LED que contenen (sobretot depenent del color, perquè els verds normalment requereixen una tensió més alta que els vermells).\nLa figura següent mostra un circuit de microprocessador amb una barra de LEDs i array de resistències.\n\n\n\nCircuit amb barra de LEDs\n\n\nLa figura següent mostra com queda una placa de circuit imprès fent servir aquests elements.\n\n\n\nAprofitament de l’espai amb barres de LED"
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#el-led-a-través-de-transistor",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#el-led-a-través-de-transistor",
    "title": "Elements de sortida electrònics (I)",
    "section": "El LED a través de transistor",
    "text": "El LED a través de transistor\nNo tots els dispositius electrònics són capaços d’oferir a les seves sortides una intensitat de corrent sortint o entrant elevats. Existeix el cas de dispositius que gairebé no arriben als pocs mil·liampers i que, per tant, són incapaços d’alimentar adequadament LEDs i altres dispositius senyalitzadors de sortida.\nTambé pot donar-se el cas que la suma de tots els corrents generats o absorbits pels diferents terminals del circuit integrat en qüestió és superior al límit recomanat pel fabricant, sobretot relacionant-ho amb la dissipació de potència en el seu interior i el perill que això comporta sobre la longevitat del C.I. mateix.\nLa solució que sempre tenim disponible és cedir la responsabilitat d’oferir corrent a un altre dispositiu. I el cas més senzill és el simple transistor BJT, ja sigui en configuració NPN com PNP.\nCom sabem, un transistor BJT presenta un factor de guany en corrent que segueix l’expressió:\n\\[I_C=\\beta_F\\cdot I_B\\]\nEl paràmetre de guany de col·lector, \\(\\beta_F\\) es pot trobar també escrit com a \\(h_{fe}\\), corresponent al mateix paràmetre en tots dos casos.\nAixí doncs, en termes generals, el que ens interessa és aplicar el transistor de manera que el corrent de col·lector sigui el necessari per a fer funcionar el dispositiu que hi posem; i a la vegada, fer que el mateix transistor es quedi amb el mínim potencial aplicat entre col·lector i emissor, de manera que la seva dissipació d’energia sigui la mínima possible. A aquest punt de treball dels transistors se l’anomena saturació.\nDe manera similar, quan el transistor no ha de conduir, ha de quedar-se amb tot el potencial disponible, fent que el corrent sigui exactament zero. A aquest punt de treball dels transistors se l’anomena tall.\nCommutar a un transistor de tall a saturació serà possible amb configuracions com les mostrades aquí:\n\n\n\nConfiguracions amb transistor NPN(esquerra) i PNP(dreta)\n\n\nQuant als càlculs necessaris per a ajustar les resistències que hi són presents, prendrem el cas NPN (el PNP és exactament igual, canviant “1” per “0” i viceversa).\nEn primer lloc volem que quan el transistor estigui en tall, aquest no provoqui el pas de corrent. Això ja ho aconsegueix la configuració mostrada.\nEn segon lloc, volem que quan el transistor condueixi (activem el LED des de l’entrada aplicant un “1” a la resistència del terminal de base del transistor), aleshores ho faci en saturació. La saturació consisteix en una mínima caiguda de potencial entre col·lector i emissor. El valor habitual és de 0.2V.\nSi el circuit està en saturació, quedaran disponibles per al LED i la resistència de col·lector un total de: \\[5V-0.2V=4.8V\\]\n(Estem considerant una alimentació de 5V).\nDe la mateixa manera, el LED mateix necessitarà 1.7V per encendre’s, de manera que la caiguda de potencial desitjat a la resistència quedarà reduïda a:\n\\[ 4.8V-1.7V=3.1V \\]\nSi volem que el LED s’encengui amb uns 15mA de corrent (lluminositat mitja-alta), aleshores necessitem una resistència de col·lector de:\n\\[R_C=\\frac{3.1}{0.015}=206.\\widehat{6}\\approx 220\\Omega\\]\nPer tant, el corrent real que en resultarà serà de:\n\\[I_C=\\frac{3.1}{220}=0.0141=14.1mA\\]\nSi treballem amb un transistor NPN de guany \\(h_{fe}=100\\) (els transistors presenten guanys com aquest o superiors), aleshores el corrent de base que ha d’existir serà de:\n\\[I_B=\\frac{I_C}{h_{fe}}=\\frac{0.0141}{100}=0.000141=0.141mA\\]\nEn la base del transistor, aquest sempre es quedarà amb una tensió de 0.7V per l’efecte díode present entre base i emissor. Així doncs, la resistència de la base presentarà una caiguda de tensió de\n\\[5V-0.7V=4.3V\\]\n(Considerant que el “1” sigui exactament 5V).\nAixí doncs, sabem corrent i tensió i, aplicant llei d’Ohm, podem trobar la resistència de base necessària:\n\\[R_B=\\frac{4.3}{0.000141}=30496.45 \\approx 27k\\Omega\\]\nObservi’s que hem arrodonit cap avall. Això és perquè la saturació s’aconsegueix amb valors més baixos de resistència, no més elevats. Si els dispositius presenten derives dels seus paràmetres, anirem més segurs si utilitzem una resistència més baixa.\nEls paràmetres que fan que aquests càlculs no siguin precisos són:\n\nLa tensió base-emissor no és constant de 0.7V\nLa tensió que necessita el LED per encendre’s no és sempre 1.7V\nLa \\(h_{fe}\\) no és independent de la tensió aplicada i presenta una tolerància elevada\n\nPer tot això, cal fer un arrodoniment de la resistència de base, \\(R_B\\), cap avall; i així assegurar-nos que s’assoleix saturació o s’està molt aprop.\nSi s’observa la característica tècnica d’un transistor real, com el BC547, s’observarà que la seva \\(h_{fe}\\) pot oscil·lar entre 110 i 800!!! Si considerem \\(h_{fe}\\) de 110, la resistència de base hauria de ser de 33kΩ, mentre que si considerem que \\(h_{fe}\\) és 800, la resistència de base hauria de pujar als 240kΩ. Evidentment ens quedaríem amb el cas més baix, el de 33kΩ.\nA més, pensi’s que 0.2V entre col·lector i emissor, amb 20mA de corrent, provoquen una dissipació de potència de 4mW. Si ens equivoquem i cauen entre col·lector i emissor més Volts per no trobar-se en saturació, estarem provocant una dissipació de potència molt major, que podria superar el màxim permès pel dispositiu concret triat. Això és molt important en muntatge miniatura superficial (transistors SMD)."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#el-relé",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#el-relé",
    "title": "Elements de sortida electrònics (I)",
    "section": "El relé",
    "text": "El relé\nUn relé és un dispositiu electrònic-mecànic que fa d’interruptor control·lat. Si passa corrent a través de la seva bobina en quantitat suficient, és capaç de tancar un contacte mecànic que activa un altre circuit, totalment independent elèctricament del primer.\n\n\n\nUn relé convencional\n\n\nAixí doncs, amb relés, podem controlar motors de 24V, bombetes de 220V i altres mecanismes simplement des d’un senyal digital tipus “0”/“1” lògic.\nMalauradament, un circuit electrònic digital no pot comandar de manera directa la bobina del relé; i necessitem, forçosament, d’un transistor per a proporcionar el corrent requerit.\nCom que un relé consta d’una bobina, i aquesta bobina ha de ser capaç de moure el mecanisme del contacte mecànic. Això vol dir que la resistència equivalent de la bobina és d’uns pocs Ohms. A més, la bobina ha de ser alimentat a una tensió que dependrà del model concret de relé que es triï.\nAixí doncs, podem trobar relés de 12V amb una bobina que presenta una resistència equivalent de 240Ω, per exemple.\nUn circuit per a condicionar la sortida digital d’algun circuit electrònic i alimentar adequadament un relé pot ser com el mostrat a la figura següent (de fet, podria construir-se l’equivalent amb transistor PNP)\n\n\n\nCircuit de control d’un relé\n\n\nEn aquest cas hem de calcular la resistència de base necessària per a fer funcionar el relé, minimitzant la caiguda de tensió entre col·lector i emissor del transistor.\nA continuació es mostren els càlculs per a un relé de 12V, 240Ω, amb transistor BC547.\nSi el transistor ha d’estar en saturació, aleshores el corrent de col·lector ha de ser:\n\\[I_C=\\frac{12-0.2}{240}=0.04917=49.17mA\\]\nAssumint una \\(h_{fe}\\) del transistor de 100, aleshores el corrent de base haurà de ser:\n\\[I_B=\\frac{I_C}{h_{fe}}=0.04917/100=0.0004917 = 0.4917mA\\]\nCom que en el terminal de base el senyal digital considerem que és de 5V per a codificar un “1” lògic, aleshores, tenint present la caiguda de 0.7V a la base del transistor, tindrem:\n\\[R_C=\\frac{5-0.7}{0.0004917}=8745.17\\approx 8k2\\Omega\\]\nAixò vol dir que necessitarem una resistència a la base del transistor d’uns 8k2Ω.\nEvidentment, succeeix el que es comentava amb els LEDs: els transistors presenten guanys no constants, de la mateixa manera que els 0.7V de base són un valor mitjà.\nTambé s’haurà observat el díode col·locat en polarització inversa en paral·lel amb el relé. Aquest díode és imprescindible perquè protegeix el transistor i l’alimentació dels pics provocats per la commutació de la bobina del relé. No oblidem que es tracta d’una bobina i el seu efecte sobre el circuit pot ser destructiu des del punt de vista de contaminar els senyals. El díode anul·la aquests espuris, protegint transistor, circuits lògics i alimentació global."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#els-leds-multiplexats",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#els-leds-multiplexats",
    "title": "Elements de sortida electrònics (I)",
    "section": "Els LEDs multiplexats",
    "text": "Els LEDs multiplexats\nEn un circuit complex, amb molts LEDs que puguin estar encesos a la vegada, ens podem trobar amb la limitació que el consum global de tots els LEDs és excessiu, o pot arribar a ser-ho en cas que tots ells s’encenguin. Això provoca que el circuit que els ha d’alimentar hagi d’estar preparat per a suportar una dissipació de potència elevada.\nNo obstant això, els LEDs són indicadors per a l’ull humà, i aquest últim presenta una limitació que ens afavoreix, i és que si un LED està encenent-se i apagant-se a una freqüència superior als 50Hz, l’ull considera que està permanentment encès. A això se li diu “persistència de la visió”, i és un fenomen conegut i estudiat en extrem.\nPodem aprofitar aquest fet, de manera que només un o uns pocs LEDs estiguin encesos a la vegada i la resta apagats, i fer un recorregut per tots els LEDs, de manera que la freqüència total (corresponent al recorregut per tots els LEDs) sigui superior a aquests 50Hz."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#un-a-un",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#un-a-un",
    "title": "Elements de sortida electrònics (I)",
    "section": "Un a un",
    "text": "Un a un\nUn circuit que podria explotar la característica esmentada fins ara, de manera individual per a cada LED, seria el de la figura següent:\n\n\n\nUn circuit amb 16 LEDs\n\n\nConsiderant els 16 LEDs del circuit mostrat anteriorment, podríem fer el cronograma corresponent a la representació de la combinació “1110 1011 1001 1011”, on el bit mostrat primer és el del LED numerat D1; i on “1” representa “LED encès”, perquè en el circuit s’encén el LED per nivell baix. Això és mostrat a la figura següent:\n\n\n\n\nCronograma de 16 LEDs multiplexats mostrant “1110 1011 1001 1011”\n\n\nLa contrapartida és que, com cada LED individual estarà apagat durant un temps (el temps que s’estigui tractant la resta de LEDs), aquest presentarà una nivell de lluminositat més baix. En funció de la relació entre el temps encès i el temps apagat, tindrem un nivell de llum efectiu determinat.\nPodem veure això també com un “duty cicle” si mirem el senyal que afecta a cada LED.\nSi observem el LED D1, aquest estarà encès (si ho ha d’estar) només 1/16 del temps. Això vol dir que el nivell de lluminositat efectiva (en mitjana) és una setzena part de la que presentaria si estigués alimentat contínuament durant tot el temps. Passarà el mateix amb qualsevol altre LED que hagi de mostrar-se encès.\nAquesta reducció de lluminositat efectiva del LED pot contrarestar-se reduint la resistència limitadora del LED. En comptes de 220Ω, podríem posar una resistència 16 vegades menor (uns 13.75Ω) o, fins i tot, traient les resistències limitadores!\nI és que en alguns circuits, on la reducció de lluminositat efectiva és molt gran, s’eliminen les resistències limitadores i es treballa sota el supòsit que el mateix dispositiu de sortida digital tindrà algun tipus de limitació de corrent sortint. Per exemple, que limiti a 50mA per terminal. Aleshores, el LED s’encendrà durant 1/16 del temps a un nivell de lluminositat de 50mA, cosa que equivaldria a un nivell de lluminositat efectiu d’uns 3.125mA."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#en-agrupacions",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#en-agrupacions",
    "title": "Elements de sortida electrònics (I)",
    "section": "En agrupacions",
    "text": "En agrupacions\nCom que una reducció de 1/16 pot ser massa forta en alguns LEDs de poca lluminositat, es pot optar per agrupar els LEDs en grups d’unes poques unitats.\nSuposem que triem una mida de grup de 4. Aleshores els LEDs s’encendran de 4 en 4 i, globalment el temps de cicle és reduirà en una quarta part. El nivell de lluminositat efectiu serà doncs de només 1/4.\nPer fer això hem de controlar quin grup de LEDs pot estar encès o no, i per tant necessitem que l’alimentació ja no sigui directament la de la font d’alimentació. Requerim ara un transistor controlat per un terminal que alimenti al grup individual que s’ha d’encendre.\nLa figura següent mostra una possible solució a l’esmentat aquí.\n\n\n\nCircuit multiplexat amb grups de 4 LEDs\n\n\nSi s’observa aquest disseny, individualment cada LED està controlat per dos terminals del microprocessador: El terminal de grup (per exemple, G2), i el terminal de LED dins del grup (per exemple, L3). Així doncs, per a encendre un LED determinat hem de donar tensió baixa (un “0”) als dos terminals que adrecen el LED concret.\nEl motiu del transistor és el de seleccionar el grup que volem adreçar, activant el grup amb un “0” en el terminal de control apropiat; mantenint a “1” la resta, evidentment.\nAmb un grup activat, podem seleccionar la combinació de LEDs d’aquell grup que volem encendre, posant a nivell baix els terminals corresponents L1, L2, L3 i L4. Això permet activar els quatre LEDs simultàniament si es desitgés.\nLa figura següent mostra com s’encendrien els 16 LEDs en aquesta disposició per a mostrar la combinació de “1110 1011 1001 1011”. De nou, un “1” indica “LED encès”. Això en aquest circuit es tradueix en una combinació determinada de nivells baixos en els terminals de selecció de grup i LED individual.\n\n\n\n\nCronograma de 16 LEDs multiplexats en grups de 4 mostrant “1110 1011 1001 1011”\n\n\nLògicament el corrent que passa per cada transistor variarà en funció de la combinació de LEDs que s’encenen, des de cap LED (0mA) fins a 4 LEDs (4 vegades la intensitat que defineixen les resistències limitadores).\nEn aquest cas concret, amb els dispositius mostrats, el corrent que passa per cada LED, quan s’encén, és d’uns 15mA, aproximadament.\nEl corrent, en termes reals, variarà en funció de la combinació, però d’una manera lleugera (1mA de diferència entre 1 LED i 4 LEDs, per al cas mostrat).\nA més, el microprocessador hauria de ser capaç de donar individualment els 15mA per cadascun dels 4 terminals que adrecen els LEDs, i uns 1.5mA per al terminal d’activació de grup. A més, no s’ha de superar el límit global amb el corrent total, que en aquest cas seria de 4 vegades 15mA més els 1.5mA, és a dir, uns 62mA."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#leds-i-registres",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#leds-i-registres",
    "title": "Elements de sortida electrònics (I)",
    "section": "LEDs i registres",
    "text": "LEDs i registres\nUna manera de reduir el consum de corrent del microprocessador i traspassar-lo a algun altre dispositiu podria ser tenir registres lògics que emmagatzemin la seqüència de LEDs que s’ha de mostrar. Podríem fer una construcció com la mostrada a la figura aquí:\n\n\n\nCircuit amb 16 LEDs a través de registres\n\n\nEs pot observar que la càrrega dels registres fa que en el microprocessador només fem servir 3 terminals: Un per a la dada, un altre per al rellotge, i un altre per a controlar el reset dels registres.\nEls registres, per la seva part, estan encadenats en cascada. La sortida de major pes (Q7) del primer element (U1) està disposada com a entrada de dades del següent element de registre (U2).\nTambé és important notar que en aquest sistema tots els LEDs poden estar il·luminats. Això provocaria un elevat consum que, potser, el circuit integrat de registres no podria tolerar. Pensem que 8 LEDs a 20mA genera un consum total de 160mA…\nPer evitar aquest problema podem triar un circuit integrat que faci la funció de “driver” de corrent. Aquest es veu en la forma de U4 i U5 en el circuit de la figura anterior, i és el circuit integrat ULN2803. Aquest circuit consta de 8 transistors NPN en configuració Darlington i és ideal per a aquest tipus de configuracions.\nEl circuit integrat ULN2803 serà l’encarregat de lliurar als LEDs tot el corrent que demanin, i tot segons el senyal lògic present als terminals d’entrada (que són les sortides del registre de desplaçament).\nLa figura següent mostra el cronograma associat a aquest circuit per a mostrar la seqüència binària “1110 1011 1001 1011”.\n\n\n\n\nCronograma de 16 LEDs amb registres i drivers mostrant “1110 1011 1001 1011”\n\n\nNoti’s que el CLR és enviat a l’inici de cada bloc d’actualització, però que en realitat seria millor no fer-lo servir. En aquest cas el registre de desplaçament 74164 fa el reset amb zeros; i això provocaria que, durant un breu període de temps, tots els LEDs estarien encesos.\nPodríem invertir aquesta situació fent que els LEDs s’encenguessin per “1”, disposant el terminal comú del pack de resistències a GND, i canviant la polaritat dels LEDs. Malauradament, això és impracticable si volem fer servir el circuit integrat ULN2803, perquè es tracta d’un grup de 8 Darlington tipus NPN. Hauríem de substituir-lo també per un circuit integrat Darlington però de tipus PNP."
  },
  {
    "objectID": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#la-tècnica-del-charlieplexing",
    "href": "posts/2010-10-22-elements-de-sortida-electronics-1/index.html#la-tècnica-del-charlieplexing",
    "title": "Elements de sortida electrònics (I)",
    "section": "La tècnica del charlieplexing",
    "text": "La tècnica del charlieplexing\nEn el cas de sistemes amb una quantitat de terminals reduït, on la mida del circuit és important, podem optar per tècniques addicionals que milloren tot això.\nFins ara s’ha vist que:\n\nFer servir multiplexació presenta un important avantatge: La quantitat de terminals utilitzats es redueix enormement, però no a un extrem mínim.\nSí és mínim, si fem servir registres; però el consum és constant i força elevat amb, en algun cas, tots els LEDs encesos a la vegada.\nLa multiplexació redueix l’índex de lluminositat en funció de la quantitat de LEDs que simultàniament s’encenen.\n\nEns interessaria un sistema que permeti la multiplexació per l’avantatge que suposa en termes de consum d’energia, però amb la reducció màxima de terminals. Amb, evidentment, el cicle més curt possible per aprofitar el màxim d’il·luminació.\nAixò és possible si estudiem com funciona el LED i com podem alimentar-lo.\nSuposem en primer lloc, dos LEDs disposats en paral·lel i amb polaritats invertides. Això es mostra a la figura següent.\n\n\n\nCharlieplexing amb 2 terminals\n\n\nSi cada extrem l’alimentem des d’un terminal del microprocessador, podem optar per les següents combinacions:\n\n\n\nT1\nT2\nLed 1\nLed 2\n\n\n\n\n0\n0\nApagat\nApagat\n\n\n1\n0\nEncès\nApagat\n\n\n0\n1\nApagat\nEncès\n\n\n1\n1\nApagat\nApagat\n\n\n\nCom es veu, les resistències en sèrie amb els terminals del microprocessador permeten limitar el corrent que passa a través dels LEDs.\nQue, amb dos terminals, alimentem dos LEDs no sembla gaire engrescador, però analitzant el cas de 3 terminals, la cosa canvia. La figura següent mostra una configuració de 6 LEDs controlats per només tres terminals.\n\n\n\nCharlieplexing amb 3 terminals\n\n\nLa taula següent recull com s’haurà d’alimentar cada terminal per a aconseguir les diferents combinacions d’encesa de LEDs:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT1\nT2\nT3\nLed 1\nLed 2\nLed 3\nLed 4\nLed 5\nLed 6\n\n\n\n\n1\n0\nZ\nEncès\nApagat\nApagat\nApagat\nApagat\nApagat\n\n\n0\n1\nZ\nApagat\nEncès\nApagat\nApagat\nApagat\nApagat\n\n\nZ\n1\n0\nApagat\nApagat\nEncès\nApagat\nApagat\nApagat\n\n\nZ\n0\n1\nApagat\nApagat\nApagat\nEncès\nApagat\nApagat\n\n\n1\nZ\n0\nApagat\nApagat\nApagat\nApagat\nEncès\nApagat\n\n\n0\nZ\n1\nApagat\nApagat\nApagat\nApagat\nApagat\nEncès\n\n\n…\n…\n…\nApagat\nApagat\nApagat\nApagat\nApagat\nApagat\n\n\n\nObservi’s que s’ha tingut en compte la possibilitat de què el microprocessador sigui capaç d’emetre un estat d’alta impedància a les seves sortides.\nLa figura següent mostra la situació amb 4 terminals, que permet disposar de 12 LEDs.\n\n\n\nCharlieplexing amb 4 terminals\n\n\nEn general, per a \\(n\\) terminals en el microprocessador, s’obté la possibilitat d’adreçar \\(n\\cdot(n-1)\\) LEDs.\n\\[  n\\textrm{ terminals} \\Longrightarrow n\\cdot (n-1) \\textrm{ LEDs}  \\]\nAixí, amb només 10 terminals podrem adreçar un total de 90 LEDs, per exemple.\nAquests totals, fora de sorprendre’ns per veure com augmenta la quantitat de LEDs de manera increïble, ens porta a una problemàtica associada; i és que la tècnica per a adreçar aquests LEDs no deixa de ser com una multiplexació i, per tant, patirem una reducció d’il·luminació important. Haurem de triar una freqüència alta d’actualització per a recórrer, un a un, tots i cadascun dels LEDs, i fer que el període complet d’escombrat sigui suficientment alt com per a donar la sensació de persistència de la visió.\nNo s’ha d’oblidar que, per a multiplexar una gran quantitat de LEDs, aquests romandran gran part del temps apagats; i per tant, el nivell d’il·luminació serà molt baix. Podem compensar-ho també augmentant el corrent per LED, i això pot portar-nos a anular-la directament. Això no és perillós, perquè el temps d’encesa del LED és baix i el que importa és el consum mitjà. A més, el consum del dispositiu que proporciona el senyal estarà control·lat pels seus propis mecanismes interns de protecció. Molts dispositius no poden proporcionar més de 25mA en els seus terminals gràcies als dispositius limitadors que incorporen.\nUn exemple d’aplicació de la tècnica de charlieplexing pot ser la construcció d’un rellotge amb LEDs disposats circularment, consistent en:\n\n60 LEDs per a indicar els minuts. Els LEDs es poden tenir encesos tots des del 0, o només aquell que sigui el del minut actual.\n12 LEDs bicolor per a indicar les hores. Un color servirà per indicar l’hora actual, mentre que l’altre serà sempre encès per a indicar on estan les marques quan s’estigui amb poca llum ambiental.\n\n\n\n\nLayout d’un rellotge amb charlieplexing\n\n\nAixò comporta que s’han de controlar, en realitat, 84 LEDs (60+12+12). Podem dividir aquest total en dues meitats, per a millorar la persistència de visió i augmentar la il·luminació resultant, a més de simplificar el layout del circuit.\nAmb dos grups de 42 LEDs necessitarem 7 terminals per a cada grup. O sigui, un total de 14 terminals de microprocessador (dos grups independents de 7 terminals).\nAixò és el mostrat a la figura anterior (layout); i la vista 3D resultant a les figures següents:\n\n\n\nVista 3D d’un rellotge amb charlieplexing (cara components)\n\n\n\n\n\nVista 3D d’un rellotge amb charlieplexing (cara pistes)\n\n\n… continuarà …"
  },
  {
    "objectID": "posts/2013-07-01-BD06-hibernate-i-jpa/index.html",
    "href": "posts/2013-07-01-BD06-hibernate-i-jpa/index.html",
    "title": "Hibernate i JPA",
    "section": "",
    "text": "Hibernate ofereix una classe nova, més eficient que Criteria, anomenada CriteriaQuery que va més enllà i permet realitzar tasques complexes sobre les dades de les taules.\nPer utilitzar la classe CriteriaQuery s’ha de fer servir el mòdul JPA (Java Persistence API) que permet associar objectes a fonts d’informació diverses (base de dades, arxius XML, etc.) en un model semblant al presentat fins ara.\nPer utilitzar les funcionalitats de JPA combinades amb Hibernate necessitem:\n\nIncloure un API de JPA per accedir a les seves funcionalitats combinades amb Hibernate: Això ho podem aconseguir afegir l’arxiu hibernate-entitymanager-4.1.8.Final.jar al CLASSPATH de la nostra aplicació (disponible des de la descàrrega del API de Hibernate) o copiar-lo a un directori local de l’aplicació. En el nostre cas s’ha inclòs en el directori libs dels arxius de projecte.\nIncloure un arxiu persistence.xml al directori META-INF de l’aplicació. Pot crear el directori i afegir l’arxiu amb la configuració del mòdul JPA. Vincularem aquí l’arxiu hibernate.cfg.xml per a què tingui en compte la configuració de Hibernate com a font d’informació per a JPA.\nDes de l’aplicació haurem d’invocar la creació d’un EntityManager que gestioni les consultes amb la base de dades. Per fer-ho haurem d’executar un codi com el següent:\nEntityManagerFactory emf = \n    Persistence.createEntityManagerFactory(\"mngr1\");\nEntityManager em = emf.createEntityManager();\n...\nEl nom mngr1 ha de coincidir amb aquell declarat en l’arxiu persistence.xml com a font de dades.\nAleshores podem demanar a aquest EntityManager que ens ofereixi un constructor de consultes CriteriaBuilder i que farem servir per construir consultes contra la base de dades (o l’origen de dades establert en el JPA):\n...\nCriteriaBuilder cb = em.getCriteriaBuilder();\n...\nPer a construir una consulta de selecció amb aquesta metodologia JPA, podem executar codi com el següent:\nCriteriaQuery&lt;Employee&gt; query = cb.createQuery(Employee.class);\nRoot&lt;Employee&gt; emp = query.from(Employee.class);\nquery.where(cb.equal(emp.get(\"lastname\"), \"King\"));\nquery.orderBy(cb.asc(usuari.get(\"firstname\")));\nList&lt;Employee&gt; result = em.createQuery(query).getResultList();\nCom veu es poden afegir restriccions de tipus WHERE i clàusules com ORDER BY. De fet, es poden construir sentències extremadament complexes a partir dels diferents elements i mètodes que ofereix CriteriaQuery.\nPer executar tasques DML sobre les dades, hem d’iniciar una transacció. Això es pot fer amb codi com el següent:\n...\nem.getTransaction().begin();\n...\n// operacions DML\n...\nem.getTransaction().commit();    // ...o rollback();\n...\nPer executar una consulta de modificació podem utilitzar diversos mètodes, entre els quals destaquen:\nConsultes JPQL (Java Persistence Query Language):\nQuery q = em.createQuery(\n    \"UPDATE Employee e SET e.salary = 18000 WHERE u.lastname='Rovirosa'\");\nq.executeUpdate();\nVincular l’objecte que reflecteix les dades (fer-lo managed) i modificar-lo en memòria:\nEmployee anna = em.find(Employee.class, 214);\nanna.setSalary(18000);\n\nLa primera operació ha importat les dades des de la base de dades a un objecte local en memòria. Qualsevol operació sobre l’objecte serà traslladada a la base de dades quan s’efectuï l’operació de COMMIT per finalitzar la transacció. A aquest fet s’indica que l’objecte importat passa a l’estat managed, indicant que a partir d’aquell moment correspon a dades reals de base de dades i queda vinculat a la seva font d’informació. Per això no cal realitzar tasques addicionals amb l’objecte per modificar-lo: simplement trobar-lo amb find(), modificar-lo i finalment fer el commit().",
    "crumbs": [
      "Inici",
      "6 Hibernate/JPA"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD06-hibernate-i-jpa/index.html#introducció-a-jpa",
    "href": "posts/2013-07-01-BD06-hibernate-i-jpa/index.html#introducció-a-jpa",
    "title": "Hibernate i JPA",
    "section": "",
    "text": "Hibernate ofereix una classe nova, més eficient que Criteria, anomenada CriteriaQuery que va més enllà i permet realitzar tasques complexes sobre les dades de les taules.\nPer utilitzar la classe CriteriaQuery s’ha de fer servir el mòdul JPA (Java Persistence API) que permet associar objectes a fonts d’informació diverses (base de dades, arxius XML, etc.) en un model semblant al presentat fins ara.\nPer utilitzar les funcionalitats de JPA combinades amb Hibernate necessitem:\n\nIncloure un API de JPA per accedir a les seves funcionalitats combinades amb Hibernate: Això ho podem aconseguir afegir l’arxiu hibernate-entitymanager-4.1.8.Final.jar al CLASSPATH de la nostra aplicació (disponible des de la descàrrega del API de Hibernate) o copiar-lo a un directori local de l’aplicació. En el nostre cas s’ha inclòs en el directori libs dels arxius de projecte.\nIncloure un arxiu persistence.xml al directori META-INF de l’aplicació. Pot crear el directori i afegir l’arxiu amb la configuració del mòdul JPA. Vincularem aquí l’arxiu hibernate.cfg.xml per a què tingui en compte la configuració de Hibernate com a font d’informació per a JPA.\nDes de l’aplicació haurem d’invocar la creació d’un EntityManager que gestioni les consultes amb la base de dades. Per fer-ho haurem d’executar un codi com el següent:\nEntityManagerFactory emf = \n    Persistence.createEntityManagerFactory(\"mngr1\");\nEntityManager em = emf.createEntityManager();\n...\nEl nom mngr1 ha de coincidir amb aquell declarat en l’arxiu persistence.xml com a font de dades.\nAleshores podem demanar a aquest EntityManager que ens ofereixi un constructor de consultes CriteriaBuilder i que farem servir per construir consultes contra la base de dades (o l’origen de dades establert en el JPA):\n...\nCriteriaBuilder cb = em.getCriteriaBuilder();\n...\nPer a construir una consulta de selecció amb aquesta metodologia JPA, podem executar codi com el següent:\nCriteriaQuery&lt;Employee&gt; query = cb.createQuery(Employee.class);\nRoot&lt;Employee&gt; emp = query.from(Employee.class);\nquery.where(cb.equal(emp.get(\"lastname\"), \"King\"));\nquery.orderBy(cb.asc(usuari.get(\"firstname\")));\nList&lt;Employee&gt; result = em.createQuery(query).getResultList();\nCom veu es poden afegir restriccions de tipus WHERE i clàusules com ORDER BY. De fet, es poden construir sentències extremadament complexes a partir dels diferents elements i mètodes que ofereix CriteriaQuery.\nPer executar tasques DML sobre les dades, hem d’iniciar una transacció. Això es pot fer amb codi com el següent:\n...\nem.getTransaction().begin();\n...\n// operacions DML\n...\nem.getTransaction().commit();    // ...o rollback();\n...\nPer executar una consulta de modificació podem utilitzar diversos mètodes, entre els quals destaquen:\nConsultes JPQL (Java Persistence Query Language):\nQuery q = em.createQuery(\n    \"UPDATE Employee e SET e.salary = 18000 WHERE u.lastname='Rovirosa'\");\nq.executeUpdate();\nVincular l’objecte que reflecteix les dades (fer-lo managed) i modificar-lo en memòria:\nEmployee anna = em.find(Employee.class, 214);\nanna.setSalary(18000);\n\nLa primera operació ha importat les dades des de la base de dades a un objecte local en memòria. Qualsevol operació sobre l’objecte serà traslladada a la base de dades quan s’efectuï l’operació de COMMIT per finalitzar la transacció. A aquest fet s’indica que l’objecte importat passa a l’estat managed, indicant que a partir d’aquell moment correspon a dades reals de base de dades i queda vinculat a la seva font d’informació. Per això no cal realitzar tasques addicionals amb l’objecte per modificar-lo: simplement trobar-lo amb find(), modificar-lo i finalment fer el commit().",
    "crumbs": [
      "Inici",
      "6 Hibernate/JPA"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD06-hibernate-i-jpa/index.html#exemple-amb-jpa-hibernate",
    "href": "posts/2013-07-01-BD06-hibernate-i-jpa/index.html#exemple-amb-jpa-hibernate",
    "title": "Hibernate i JPA",
    "section": "2. Exemple amb JPA + Hibernate",
    "text": "2. Exemple amb JPA + Hibernate\nS’ha fet una nova versió del bloc de programes de prova per demostrar l’ús de JPA combinat amb Hibernate.\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple número 8\n\n\nPodrà observar que l’estructura d’arxius és gairebé idèntica a la vista anteriorment, però ara s’incorpora el directori META-INF amb l’arxiu de configuració persistence.xml al seu interior. Aquest arxiu correspon a la configuració de JPA, i que en el nostre cas és com es mostra aquí:\n\n\npersistence.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;persistence xmlns=\"http://java.sun.com/xml/ns/persistence\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd\"\n    version=\"1.0\"&gt;\n\n    &lt;persistence-unit name=\"mngr1\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n        &lt;properties&gt;\n            &lt;property name=\"hibernate.ejb.cfgfile\" value=\"hibernate.cfg.xml\" /&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n\nObservi que aquest arxiu només s’encarrega de declarar una unitat JPA anomenada mngr1 i que es faci ús de la configuració present a l’arxiu hibernate.cfg.xml com a font d’informació per a l’origen de dades.\nEn realitat aquest arxiu també podria contenir tota la informació en el seu interior (driver, usuari, base de dades, etc.) però s’ha preferit mantenir l’arxiu separat per claredat.\nLa resta d’arxius dels programes de mostra estan pràcticament iguals, només canviant el DAO per adequar-lo a les característiques de JPA.\nObservi que el DAO conté una funció anomenada setUp(), que omple dues variables clau per a l’ús de JPA des de l’aplicació. El seu objectiu és habilitar JPA i iniciar un objecte de tipus EntityManager que anomenem em i un altre de classe CriteriaBuilder que anomenem cb. Gràcies a aquests dos objectes podrem accedir i manipular les dades de la base de dades. Aquesta funció és cridada tot just iniciar-se el programa.\nCom veu, la càrrega programàtica d’aquesta modalitat és menor. JPA és un API optimitzat per a l’accés a informació que resideixi en multitud de possibles orígens de dades i es fa servir en bona part del desenvolupament d’aplicacions reals.",
    "crumbs": [
      "Inici",
      "6 Hibernate/JPA"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html",
    "href": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html",
    "title": "XND - XPath i XQuery",
    "section": "",
    "text": "Les bases de dades natives XML (XML native database) ofereixen un mecanisme adient per a la consulta sobre dades que resideixin en documents XML.\nEn aquest sentit, les dades estan estructurades en la base de dades (que ara és un o més documents XML) en la forma d’una estructura en arbre invertit, on el seu creador haurà definit els noms dels nodes i la seva distribució:\n\n\nmondial.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE mondial SYSTEM \"mondial.dtd\"&gt;\n&lt;mondial&gt;\n  &lt;country car_code=\"AND\" area=\"450\" capital=\"cty-Andorra-Andorra-la-Vella\" memberships=\"org-CE org-ECE org-Interpol org-IFRCS org-IOC org-ITU org-UN org-UNESCO org-WIPO\"&gt;\n    &lt;name&gt;Andorra&lt;/name&gt;\n    &lt;population&gt;72766&lt;/population&gt;\n...\n    &lt;border country=\"F\" length=\"60\"/&gt;\n    &lt;border country=\"E\" length=\"65\"/&gt;\n    &lt;city id=\"cty-Andorra-Andorra-la-Vella\" is_country_cap=\"yes\" country=\"AND\"&gt;\n      &lt;name&gt;Andorra la Vella&lt;/name&gt;\n      &lt;longitude&gt;1.3&lt;/longitude&gt;\n      &lt;latitude&gt;42.3&lt;/latitude&gt;\n      &lt;population year=\"87\"&gt;15600&lt;/population&gt;\n    &lt;/city&gt;\n  &lt;/country&gt;\n\n...\n\n  &lt;desert id=\"desert-Atacama\" country=\"RCH\"&gt;\n    &lt;name&gt;Atacama&lt;/name&gt;\n...\n    &lt;area&gt;181300&lt;/area&gt;\n    &lt;longitude&gt;-69.25&lt;/longitude&gt;\n    &lt;latitude&gt;-24.5&lt;/latitude&gt;\n  &lt;/desert&gt;\n&lt;/mondial&gt;\n\nEl fragment mostrat correspon a la base de dades MondialDB, que pot descarregar-se lliurament aquí i que serà utilitzada aquí per als exemples i exercicis.\nLes consultes sobre XND són de natura diferents respecte de les conegudes fins ara arran de l’estructura interna d’aquests documents. Per tant, els llenguatges existents per fer-hi consultes també són diferents.\nTrobem així que ara no podem utilitzar llenguatges com SQL, perquè aquí no tenen sentit. Pel contrari, existeix XPath i XQuery com els llenguatges estrella per a l’extracció de dades d’arxius XML i XND.\nEn concret, XPath és un llenguatge centrat en el recorregut descendent a través del XML, realitzant filtrat i agrupació, mitjançant un llenguatge senzill amb una col·lecció de funcions i operacions limitada.\nPer altra banda, XQuery permet construir estructures més complexes basades en un iterador (bucle) de tipus for en el que es coneix com construcció FLWOR (for-let-where-order-result).\nA més, existeixen diferents API disponibles per als diversos llenguatges de programació que permeten connectar amb aquest tipus de bases de dades i arxius XML per tal d’executar consultes amb aquests dos llenguatges de programació.",
    "crumbs": [
      "Inici",
      "8 XND: XPath/XQuery"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#introducció",
    "href": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#introducció",
    "title": "XND - XPath i XQuery",
    "section": "",
    "text": "Les bases de dades natives XML (XML native database) ofereixen un mecanisme adient per a la consulta sobre dades que resideixin en documents XML.\nEn aquest sentit, les dades estan estructurades en la base de dades (que ara és un o més documents XML) en la forma d’una estructura en arbre invertit, on el seu creador haurà definit els noms dels nodes i la seva distribució:\n\n\nmondial.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE mondial SYSTEM \"mondial.dtd\"&gt;\n&lt;mondial&gt;\n  &lt;country car_code=\"AND\" area=\"450\" capital=\"cty-Andorra-Andorra-la-Vella\" memberships=\"org-CE org-ECE org-Interpol org-IFRCS org-IOC org-ITU org-UN org-UNESCO org-WIPO\"&gt;\n    &lt;name&gt;Andorra&lt;/name&gt;\n    &lt;population&gt;72766&lt;/population&gt;\n...\n    &lt;border country=\"F\" length=\"60\"/&gt;\n    &lt;border country=\"E\" length=\"65\"/&gt;\n    &lt;city id=\"cty-Andorra-Andorra-la-Vella\" is_country_cap=\"yes\" country=\"AND\"&gt;\n      &lt;name&gt;Andorra la Vella&lt;/name&gt;\n      &lt;longitude&gt;1.3&lt;/longitude&gt;\n      &lt;latitude&gt;42.3&lt;/latitude&gt;\n      &lt;population year=\"87\"&gt;15600&lt;/population&gt;\n    &lt;/city&gt;\n  &lt;/country&gt;\n\n...\n\n  &lt;desert id=\"desert-Atacama\" country=\"RCH\"&gt;\n    &lt;name&gt;Atacama&lt;/name&gt;\n...\n    &lt;area&gt;181300&lt;/area&gt;\n    &lt;longitude&gt;-69.25&lt;/longitude&gt;\n    &lt;latitude&gt;-24.5&lt;/latitude&gt;\n  &lt;/desert&gt;\n&lt;/mondial&gt;\n\nEl fragment mostrat correspon a la base de dades MondialDB, que pot descarregar-se lliurament aquí i que serà utilitzada aquí per als exemples i exercicis.\nLes consultes sobre XND són de natura diferents respecte de les conegudes fins ara arran de l’estructura interna d’aquests documents. Per tant, els llenguatges existents per fer-hi consultes també són diferents.\nTrobem així que ara no podem utilitzar llenguatges com SQL, perquè aquí no tenen sentit. Pel contrari, existeix XPath i XQuery com els llenguatges estrella per a l’extracció de dades d’arxius XML i XND.\nEn concret, XPath és un llenguatge centrat en el recorregut descendent a través del XML, realitzant filtrat i agrupació, mitjançant un llenguatge senzill amb una col·lecció de funcions i operacions limitada.\nPer altra banda, XQuery permet construir estructures més complexes basades en un iterador (bucle) de tipus for en el que es coneix com construcció FLWOR (for-let-where-order-result).\nA més, existeixen diferents API disponibles per als diversos llenguatges de programació que permeten connectar amb aquest tipus de bases de dades i arxius XML per tal d’executar consultes amb aquests dos llenguatges de programació.",
    "crumbs": [
      "Inici",
      "8 XND: XPath/XQuery"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#installació-de-basex",
    "href": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#installació-de-basex",
    "title": "XND - XPath i XQuery",
    "section": "2. Instal·lació de BaseX",
    "text": "2. Instal·lació de BaseX\nEl primer que hem de fer és disposar d’una instal·lació d’alguna aplicació que permeti treballar en aquest entorn.\nDe sistemes XND n’hi ha un grapat, però nosaltres ens centrarem en el producte BaseX.\nAquest producte està disponible en el mateix dipòsit estàndard d’Ubuntu, de manera que només necessitem treballar des de apt-get per gestionar la seva instal·lació.\nAixí doncs, els passos seran els següents:\n\nActualitzar primer el sistema operatiu:\nsudo aptitude update && sudo aptitude upgrade\nInstal·lar JDK6 (si no estava instal·lat prèviament:\nsudo aptitude install openjdk-6-jdk\nConfigurar JDK6 o JDK7 com a versió per defecte, i així disposar de les dues versions instal·lades en el sistema, deixant la desitjada com a versió per defecte de línia d’ordres:\nsudo update-alternatives --config java\nsudo update-alternatives --config javac\nsudo update-alternatives --config javadoc\nsudo update-alternatives --config javap\nsudo update-alternatives --config javah\nsudo update-alternatives --config javaws\nSi vostè desitja deixar JDK6 com a versió per defecte per compilar programes en línia d’ordres, només cal que així ho indiqui. Podrà comprovar quina és la versió configurada fent:\njava -version\nInstal·lar BaseX:\nsudo aptitude install basex\nDescarregar la base de dades de mostra MONDIAL (The MONDIAL Database) en format XML:\nwget http://www.dbis.informatik.uni-goettingen.de/Mondial/mondial.xml\nObrir BaseX en mode gràfic:\nbasexgui\nCrear una base de dades nova a partir de l’arxiu mondial.xml descarregat i amb nom “mondial”\n\nEn aquest moment ja disposa de les eines necessàries per poder aprendre XPath/XQuery\nAra pot veure com és la base de dades amb què farem proves, tot recorrent-la gràficament amb l’aplicació i observant el document associat. Observi que quan se selecciona una branca de l’arbre XML, només aquella part serà mostrada en el visor de text i quedarà marcat en el visor gràfic.",
    "crumbs": [
      "Inici",
      "8 XND: XPath/XQuery"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#consultes-xpath",
    "href": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#consultes-xpath",
    "title": "XND - XPath i XQuery",
    "section": "3. Consultes XPath",
    "text": "3. Consultes XPath\nXPath és, com s’ha dit, un llenguatge de consultes senzill que permet recórrer l’arbre XML de manera descendent i filtrar els elements (nodes) pels quals passem en aquest recorregut amb diversos criteris.\nEn aquest sentit, el resultat d’una consulta XPath és, en termes generals, un document XML. Aquest resultat és la col·lecció de nodes i elements que hagin “sobreviscut” a aquest recorregut i filtrat descendent.\n\n3.1. Recorregut de l’arbre XML\nLa forma bàsica d’una sentència XPath s’assembla molt a la d’un camí de disc, on els directoris són els nodes presents al XML.\nEl node arrel es representa com a //. A partir d’aquí, podem incloure un camí concret descendent per l’arbre XML, tot filtrant què volem que quedi en el resultat.\nVegem alguns exemples:\n\nTot l’arbre del document:\n//mondial\nEl resultat serà tota la base de dades sencera.\nTots els nodes del document:\n//*\nEl resultat, tot i semblar el mateix, conceptualment és un altre: tots els nodes que es trobin penjant de l’arrel (que en aquest cas coincideix).\nTots l’arbre del document si el document és un altre:\ndoc('/Users/felix/Desktop/curset/biblio.xml')//biblioteca\nObservi que és possible especificar un arxiu determinat mitjançant la funció doc(). XPath presenta algunes funcions interessants que anirem descobrint al llarg dels exemples.\nObservi també com s’ha indicat el node arrel i el node biblioteca que és l’element inicial del XML utilitzat a l’exemple.\nInformació dels diferents continents:\n//mondial/continent\nExtreure només els noms dels continents:\n//mondial/continent/name\nEl nom de tots els països que apareixen a la base de dades:\n//mondial/country/name\nVegi com el resultat ha estat l’extracció de tots els nodes name que pengin d’un node country, que pengin directament de mondial. Entengui que el resultat és un XML i que hem eliminat altres camins de l’arbre en baixar per aquesta branca, però que en cap cas hem dit que ens quedem en un o un altre país (no s’ha fet filtrat). És per això que veurà els noms de tots els països. És com si baixéssim en paral·lel per totes les branques que compleixin el camí indicat.\nNomés els noms en format text (entrant en el text del tag):\n//mondial/continent/name/text()\nAquesta funció fa que només quedi el text que és contingut dins dels nodes que han arribat a aquell punt (nodes name). Com que BaseX no gestiona el formatat, veurem el text tot seguit, però en realitat el que tenim és una col·lecció (llista) de cadenes de text.\nInformació millor presentada:\nstring-join(//mondial/continent/name/text(), ', ')\nAquesta funció uneix la llista de texts obtinguda posant caràcters de coma entre cada parell, retornant una única cadena de text de resultat.\nLlistat de conceptes presents a la base de dades:\ndistinct-values(//mondial/*/node-name())\nObservem diversos punts a comentar aquí:\n\nPer una banda, el caràcter * farà de comodí per indicar que en aquest punt estem baixant un nivell dins del XML, però no ens importa com es digui en node concret per on baixem aquest nivell. I pensi que estem indicant que s’ha de baixar un i només un nivell. No representa una quantitat arbitrària de nivells, sinó que no ens importa com es digui el nivell.\nTot i que no ens importa quin node baixem, igualment volem aplicar-hi una funció. En concret, la funció node-name() retorna el nom del node del node en què estiguem situats. Així doncs, si hem baixat per country, el nom serà “country”, i si hem baixat per river, serà “river”.\nEl distinct-values() és necessari per eliminar duplicats en el resultat obtingut, fent que només es mostri una vegada cadascun dels conceptes trobats.\n\n\n\n\n3.2. Filtrat de nodes\nQuan volem filtrar nodes en l’arbre, ho farem indicant entre claudàtors [] una expressió que representi un criteri de filtrat. Quan l’expressió indicada es compleixi, aquell node “passarà” el filtre i romandrà al resultat de la consulta.\nEls filtres podem posar-los en qualsevol node d’un recorregut descendent com els vistos fins ara, de tal manera que podem combinar filtres diferents en nivells diferents del nostre recorregut.\nObservi el següent exemple:\n//mondial/country[name='Spain']/province[name='Catalonia']/city/name\nEn aquest cas, el recorregut que fem és, en realitat, //mondial/country/province/city/name. És a dir, baixem pels nodes de l’arbre XML fins al nom de les ciutats de les províncies dels països.\nPerò no volem tots els països, així que afegim el filtre sobre el nom del país en el nivell de country. El criteri és clar: Només volem aquell país que es diu “Spain”. Un cop aquest filtrat s’hagi efectuat, només quedarà un node país per baixar i continuarà el processament del camí.\nEn el nivell de província, tornem a aplicar un filtre sobre el nom de la província, de manera que només quedi aquella amb nom “Catalonia”.\nAra bé, observi que, en realitat, el filtre ha fet un descens per l’arbre XML paral·lel al que s’estava fent per obtenir la informació resultant. Quan indiquem que miri el name en els dos casos, s’està baixant a aquell node per comprovar si es compleix o no. I, de fet, podríem baixar més d’un nivell si volguéssim.\nA més, podem també filtrar pel valor d’un atribut d’un node, posant el signe @ davant del nom de l’atribut.\nEls operadors que podem utilitzar per escriure aquests filtres són els següents:\n\n\n\nOperador\nDescripció\nExemple\n\n\n\n\n|\nCalcula la unió de dos conjunts\n//llibres | //cds\n\n\n+\nSuma\n6 + 4\n\n\n-\nResta\n6 - 4\n\n\n*\nMultiplicació\n6 * 4\n\n\ndiv\nDivisió\n8 div 4\n\n\n=\nIgualtat\npreu=9.80\n\n\n!=\nDiferent\npreu!=9.80\n\n\n&lt;\nMenor que\npreu&lt;9.80\n\n\n&lt;=\nMenor o igual\npreu&lt;=9.80\n\n\n&gt;\nMajor que\npreu&gt;9.80\n\n\n&gt;=\nMajor o igual\npreu&gt;=9.80\n\n\nor\no\npreu=9.80 or preu=9.70\n\n\nand\ni\npreu&gt;9.00 and preu&lt;9.90\n\n\nmod\nMòdul (residu)\n5 mod 2\n\n\n\nVegem ara uns quants exemples:\n\nInformació específica d’un país, cercada pel valor d’un node fill:\n//mondial/country[name='Spain']\nAixò funciona perquè dins del tag &lt;country&gt; hi ha un altre anomenat &lt;name&gt; amb el text corresponent al nom del país.\nInformació específica d’un país, cercada a través d’un atribut:\n//mondial/country[@car_code='E']\nNom dels rius que consten a Espanya\n//mondial/river[@country=\"E\"]/name\nLlistat dels països amb més de 50 milions d’habitants:\n//mondial/country[population&gt;50000000]/name\nDiferents formes de govern dels països amb més de 50 milions d’habitants:\ndistinct-values(//mondial/country[population&gt;50000000]/government)\nQuantitat de països a la base de dades:\ncount(//mondial/country)\nAquí veu que existeixen funcions d’agregació com count(), sum(), max(), etc. Vegi la llista de funcions al final de l’article.\nQuantitat de ciutats espanyoles:\ncount(//mondial/country[name='Spain']/province/city)\nQuantitat de diferents formes de govern dels països de més de 50 milions d’habitants:\ncount(distinct-values(//mondial/country[population&gt;50000000]/government))\nNom de les ciutats espanyoles:\n//mondial/country[name='Spain']/province/city/name\nCiutats espanyoles amb més de 200.000 habitants:\n//mondial/country[name='Spain']/province/city[population&gt;200000]/name\nNoms de província espanyoles:\n//mondial/country[name='Spain']/province/name\nPaïsos d’Europa:\n//mondial/country[encompassed/@continent='europe']/name\nO també:\n//mondial/country[encompassed[@continent='europe']]/name\nI és que podem aplicar filtres sobre filtres!\nRius de països europeus:\n//mondial/river[@country=//mondial/country[encompassed/@continent='europe']/@car_code]/name\nI és que podem fer també subconsultes!\nRius europeus amb una longitud de, com a mínim, la meitat de longitud que el riu més llarg de tot el mon:\n//mondial/river[\n    @country=//mondial/country[encompassed/@continent='europe']/@car_code \n    and \n    length&gt;=max(//mondial/river/length) div 2\n]/name\nObservi com, per filtrar els rius europeus, s’ha fet que el codi de país sigui un dels presents a la llista de la subconsulta de països europeus. La igualtat com a condició és, en realitat, com un IN de SQL. És a dir, si un dels dos elements és una llista, el que fa és buscar el valor dins de la llista.\nLa quantitat d’habitants de la ciutat espanyola amb més habitants:\nmax(//mondial/country[name='Spain']/province/city/population)\nLa ciutat espanyola amb més habitants:\n//mondial/country[name='Spain']/province/city[population=max(\n    //mondial/country[name='Spain']/province/city/population)]/name\nO també:\n//mondial/country[name='Spain']/province/city[population=max(\n    ../../province/city/population)]/name\nObservi’s que estem fent una subconsulta i que la subconsulta pot ser relativa al punt on s’aplica el filtrat (segon cas).\nRius amb nom començat amb la lletra ‘G’):\n//mondial/river[matches(name,'^G.*')]/name\nLa funció matches(text, expressió_regular) permet verificar expressions contra expressions regulars estàndard (tipus grep).\nNom de totes les ciutats de més d’un milió habitants (independentment de si el país està subdividit en províncies o no):\n//mondial/country/descendant::city[population&gt;1000000]/name\nL’operador descendant::node indica explorar tots i cadascun dels camins inferiors que continguin el node indicat, independentment del seu nivell dins de l’arbre. Així doncs, ens permet buscar un node fill per sota d’un punt de l’arbre quan no sabem en quin nivell de profunditat es troba.\n\nAmb tot, pot comprovar que les consultes que es poden arribar a escriure cobriran gran part dels requeriments d’extracció d’informació que necessitarem per construir vistes d’usuari. Això ja ens està bé, però de tant en tant ens trobem amb casos específics que requereixen d’alguna cosa més que el recorregut descendent amb filtrat.\n\n\n3.3. Resum de funcions XPath/XQuery agrupades per concepte\nQuant a les funcions presentades ara, tingui present que algunes poden aplicar-se sobre el node actual, mentre que d’altres només accepten el pas per argument. No s’ha indicat aquí quin cas és cadascun per reduir la complexitat del llistat, tot i que els casos en què s’aplica un o l’altre cas són en general força evidents. Per exemple: //biblioteca/llibre[position()&gt;3]/text()\nFuncions sobre els accessors:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:node-name(node)\nRetorna el nom del node indicat\n\n\nfn:nilled(node)\nRetorna cert si el node és nul\n\n\nfn:data(item.item,...)\nPren una seqüència i retorna la seqüència de valors atòmics\n\n\nfn:base-uri(node)\nRetorna el valor de la propietat base-uri del node indicat\n\n\nfn:document-uri(node)\nRetorna el valor de la propietat document-uri del node indicat\n\n\n\nFuncions d’error i traça:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:error([error[,descripció[,objecte-error]]])\nGenera i retorna un error\n\n\nfn:trace(valor,etiqueta)\nUsat per depurar consultes\n\n\n\nFuncions sobre valors numèrics:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:number(arg)\nRetorna el valor numèric de l’argument\n\n\nfn:abs(num)\nRetorna el valor absolut\n\n\nfn:ceiling(num)\nRetorna l’enter més petit que és major o igual a l’argument\n\n\nfn:floor(num)\nRetorna l’enter més gran que és menor o igual a l’argument\n\n\nfn:round(num)\nArrodoneix a l’enter més proper\n\n\nfn:round-half-to-even(num)\nArrodoneix a l’enter més proper que sigui parell\n\n\n\nFuncions sobre valors de text:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:string(arg)\nRetorna el valor de text de l’argument\n\n\nfn:codepoints-to-string(int,int,...)\nRetorna una cadena a partit d’una seqüència de codis numèrics de caràcter\n\n\nfn:string-to-codepoints(string)\nRetorna la seqüència de codis de caràcter corresponent a la cadena\n\n\nfn:codepoint-equal(comp1,comp2)\nCert si els texts són iguals segons Unicode\n\n\nfn:compare(comp1,comp2[,joc_caracters])\nCompara les cadenes seguint el joc de caràcters indicat. Retorna -1, 0 o 1\n\n\nfn:concat(string,string)\nRetorna la concatenació de les cadenes\n\n\nfn:string-join(seqüència,sep)\nRetorna una cadena que conté els ítems indicats amb el separador indicat\n\n\nfn:substring(string,inici[,long])\nTreu una subcadena d’una cadena\n\n\nfn:string-length(string)\nRetorna la quantitat de caràcters de la cadena\n\n\nfn:normalize-space(string)\nElimina espais sobrants de la cadena (inicial, final i repetits)\n\n\nfn:normalize-unicode()\nNormalitza seguint les normes Unicode\n\n\nfn:upper-case(string)\nConverteix la cadena a majúscules\n\n\nfn:lower-case(string)\nConverteix la cadena a minúscules\n\n\nfn:translate(string1,string2,string3)\nSubstitueix en string1 cada caràcter de string2 pel corresponent de string3\n\n\nfn:escape-uri(string,esc-res)\nEscapa la cadena seguint les normes per a URIs\n\n\nfn:contains(string1,string2)\nRetorna cert si la primera cadena conté el text de la segona\n\n\nfn:starts-with(string1,string2)\nRetorna cert si la primera cadena comença amb el text de la segona\n\n\nfn:ends-with(string1,string2)\nRetorna cert si la primera cadena acaba amb el text de la segona\n\n\nfn:substring-before(string1,string2)\nExtreu la part prèvia de la primera cadena respecte on apareix la segona\n\n\nfn:substring-after(string1,string2)\nExtreu la part posterior de la primera cadena respecte on apareix la segona\n\n\nfn:matches(string,regexp)\nRetorna cert si la cadena compleix l’expressió regular indicada\n\n\nfn:replace(string,regexp,replace)\nSubstitueix les troballes de l’expressió regular per la cadena de substitució\n\n\nfn:tokenize(string,regexp)\nRetalla la cadena utilitzant l’expressió regular com a recerca de separador\n\n\n\nFuncions sobre URIs:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:resolve-uri(relative,base)\nResol la URI a partir de la base i la part relativa\n\n\n\nFuncions sobre valors booleans:\n\n\n\nNom\nDescripció\n\n\n\n\nfn:boolean(arg)\nRetorna el valor booleà de l’argument indicat\n\n\nfn:not(arg)\nAvalua el contrari de l’argument\n\n\nfn:true()\nÉs el valor cert\n\n\nfn:false()\nÉs el valor fals\n\n\n\nFuncions sobre valors data-hora i intervals:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:dateTime(date,time)\nConverteix els arguments en una data i hora\n\n\nfn:years-from-duration(dur)\nRetorna l’enter que representa els anys de l’interval\n\n\nfn:months-from-duration(dur)\nRetorna l’enter que representa els mesos de l’interval\n\n\nfn:days-from-duration(dur)\nRetorna l’enter que representa els dies de l’interval\n\n\nfn:hours-from-duration(dur)\nRetorna l’enter que representa les hores de l’interval\n\n\nfn:minutes-from-duration(dur)\nRetorna l’enter que representa els minuts de l’interval\n\n\nfn:seconds-from-duration(dur)\nRetorna l’enter que representa els segons de l’interval\n\n\nfn:years-from-dateTime(datetime)\nRetorna l’enter que representa els anys de la data/hora\n\n\nfn:months-from-dateTime(datetime)\nRetorna l’enter que representa els mesos de la data/hora\n\n\nfn:days-from-dateTime(datetime)\nRetorna l’enter que representa els dies de la data/hora\n\n\nfn:hours-from-dateTime(datetime)\nRetorna l’enter que representa les hores de la data/hora\n\n\nfn:minutes-from-dateTime(datetime)\nRetorna l’enter que representa els minuts de la data/hora\n\n\nfn:seconds-from-dateTime(datetime)\nRetorna l’enter que representa els segons de la data/hora\n\n\nfn:timezone-from-dateTime(datetime)\nRetorna el fus horari de la data/hora\n\n\nfn:years-from-date(date)\nRetorna l’enter que representa els anys de la data\n\n\nfn:months-from-date(date)\nRetorna l’enter que representa els mesos de la data\n\n\nfn:days-from-date(date)\nRetorna l’enter que representa els dies de la data\n\n\nfn:timezone-from-date(date)\nRetorna el fus horari de la data\n\n\nfn:hours-from-time(time)\nRetorna l’enter que representa les hores de la hora\n\n\nfn:minutes-from-time(time)\nRetorna l’enter que representa els minuts de la hora\n\n\nfn:seconds-from-time(time)\nRetorna l’enter que representa els segons de la hora\n\n\nfn:timezone-from-time(time)\nRetorna el fus horari de la hora\n\n\nfn:adjust-dateTime-to-timezone(datetime,timezone)\nAssocia el fus horari a la data/hora\n\n\nfn:adjust-date-to-timezone(datetime,timezone)\nAssocia el fus horari a la data\n\n\nfn:adjust-time-to-timezone(datetime,timezone)\nAssocia el fus horari a la hora\n\n\n\nFuncions sobre nodes:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:name(nodeset)\nRetorna el nom del primer node del conjunt\n\n\nfn:local-name(nodeset)\nRetorna el nom del primer node del conjunt sense el prefix del namespace\n\n\nfn:namespace-uri(nodeset)\nRetorna el URI del namespace del primer node del conjunt\n\n\nfn:lang(lang)\nRetorna cert si l’idioma del node actual correspon a l’especificat. S’indica com a text (\"en\")\n\n\nfn:root(node)\nRetorna el node arrel de l’arbre a què pertany el node indicat\n\n\n\nFuncions sobre seqüències:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:index-of(seqüència, item)\nRetorna la posició de l’element cercat a la seqüència de recerca\n\n\nfn:remove(seqüència, pos)\nElimina l’element situat a la posició indicada\n\n\nfn:empty(seqüència)\nRetorna cert si l’argument és una seqüència buida\n\n\nfn:exists(seqüència)\nRetorna cert si l’argument no és una seqüència buida\n\n\nfn:distinct-values(seqüència)\nRetorna la seqüència neta de duplicats\n\n\nfn:insert-before(seqüència,pos,item)\nInsereix l’element indicat just abans de la posició especificada\n\n\nfn:reverse(seqüència)\nInverteix l’ordre dels elements de la seqüència\n\n\nfn:subsequence(seqüència,pos,len)\nExtreu part d’una seqüència\n\n\nfn:unordered(seqüència)\nRetorna els elements en un ordre dependent de la implementació\n\n\n\nFuncions sobre cardinalitat de seqüències:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:zero-or-one(seqüència)\nRetorna l’argument si conté zero o un element\n\n\nfn:one-or-more(seqüència)\nRetorna l’argument si conté un element com a mínim\n\n\nfn:exactly-one(seqüència)\nRetorna l’argument si conté exactament un sol element\n\n\n\nFuncions d’igualtat de seqüències:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:deep-equal(param1,param2)\nRetorna cert si els arguments són exactament iguals dins de les seves jerarquies\n\n\n\nFuncions d’agregació:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nfn:count(seqüència)\nRetorna la quantitat d’elements\n\n\nfn:avg(seqüència)\nRetorna el valor mitjà dels elements de la seqüència\n\n\nfn:max(seqüència)\nRetorna el valor màxim dels elements de la seqüència\n\n\nfn:min(seqüència)\nRetorna el valor mínim dels elements de la seqüència\n\n\nfn:sum(seqüència)\nRetorna el total de sumar els elements de la seqüència\n\n\n\nFuncions sobre contexts:\n\n\n\nNom\nDescripció\n\n\n\n\nfn:position()\nRetorna l’índex de l’element en el seu entorn\n\n\nfn:last()\nRetorna l’índex de l’últim element en el seu entorn\n\n\nfn:current-dateTime()\nRetorna la data/hora actual\n\n\nfn:current-date()\nRetorna la data actual\n\n\nfn:current-time()\nRetorna la hora actual\n\n\nfn:implicit-timezone()\nRetorna el fus horari implícit\n\n\nfn:default-collation()\nRetorna el joc de caràcters actual\n\n\nfn:static-base-uri()\nRetorna el valor de base-uri actual\n\n\n\nLes funcions matemàtiques científiques estan definides en el namespace math, i per tant, quan són invocades, cal esmentar-ho explícitament. Per exemple: math:sqrt(42).\nFuncions matemàtiques científiques:\n\n\n\n\n\n\n\nNom\nDescripció\n\n\n\n\nmath:pi()\nRepresenta una aproximació al valor de \\(\\pi\\)\n\n\nmath:exp(x)\nRetorna el valor de \\(e^x\\)\n\n\nmath:exp10(x)\nRetorna el valor de \\(10^x\\)\n\n\nmath:log(x)\nRetorna el logaritme natural de l’argument\n\n\nmath:log10(x)\nRetorna el logaritme en base 10 de l’argument\n\n\nmath:pow(x,y)\nRetorna el valor de \\(x^y\\)\n\n\nmath:sqrt(x)\nRetorna l’arrel quadrada de l’argument\n\n\nmath:sin(x)\nRetorna el sinus de l’angle subministrat\n\n\nmath:cos(x)\nRetorna el cosinus de l’angle subministrat\n\n\nmath:tan(x)\nRetorna la tangent de l’angle subministrat\n\n\nmath:asin(x)\nRetorna l’angle aplicant la funció inversa del sinus\n\n\nmath:acos(x)\nRetorna l’angle aplicant la funció inversa del cosinus\n\n\nmath:atan(x)\nRetorna l’angle aplicant la funció inversa de la tangent\n\n\nmath:atan2(y,x)\nRetorna l’angle aplicant la funció inversa de la tangent sobre (y/x)\n\n\n\nEls tipus de dades presents a XPath/XQuery són: xs:float, xs:double, xs:decimal, xs:integer, xs:long, xs:int, xs:short, xs:byte, xs:unsignedLong, xs:unsignedInt, xs:unsignedShort, xs:unsignedByte, xs:duration, xs:dateTime, xs:date, xs:time, entre d’altres\nPer a l’especificació d’arguments de les funcions, poden utilitzar-se els elements addicionals a més dels tipus de dades presentats:\nEspecificació d’elements en arguments de funcions:\n\n\n\nTipus d’element\nPermet\n\n\n\n\nnode()\nQualsevol node\n\n\nelement()\nQualsevol element de node\n\n\nelement(nom)\nL’element de node amb el nom indicat\n\n\nattribute()\nQualsevol atribut de node\n\n\n\nI pot indicar-se també la cardinalitat dels arguments:\nIndicadors de cardinalitat per als arguments:\n\n\n\nIndicador\nSignificat\n\n\n\n\ncap (blanc)\nexactament un element\n\n\n?\nZero o un element\n\n\n+\nUn o més elements\n\n\n*\nQualsevol quantitat d’elements (zero o més)",
    "crumbs": [
      "Inici",
      "8 XND: XPath/XQuery"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#consultes-flwor-xquery",
    "href": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#consultes-flwor-xquery",
    "title": "XND - XPath i XQuery",
    "section": "4. Consultes FLWOR (XQuery)",
    "text": "4. Consultes FLWOR (XQuery)\nXQuery ofereix un mecanisme de consultes més avançat que es munta sobre XPath. En concret, quan treballem amb XQuery, treballem amb la construcció FLWOR:\n\n\n\n\n\n\nNota\n\n\n\nFLWOR (XQuery) FLWOR = for - let - where - order by - return\n\n\nAquestes construccions permeten fer el recorregut per un arbre XML i executar alguna tasca sobre cadascun dels elements trobats, incloent l’aplicació de filtrat i càlcul d’expressions. A més, incorpora la possibilitat d’aplicar ordenació dels resultats.\nUn FLWOR, com a mínim, ha de contenir el iterador de bucle for i un return per obtenir algun resultat. Els altres tres elements (let, where i order by són opcionals).\nAnalitzem les diferents parts:\n\nAmb la clàusula for especifiquem el conjunt d’elements que volem recórrer. La notació és:\nfor $variable in //...consulta...XPath...\nPer tant, indiquem quina variable volem utilitzar per emmagatzemar els diferents elements trobats i la consulta XPath que ens generi la llista d’elements. Aquí podem posar una consulta XPath tant complexa com les vistes fins ara.\nAmb la clàusula let podem indicar assignacions i càlculs en forma d’expressions avaluades. Normalment s’utilitza sintaxi XPath i podem utilitzar la variable de bucle o variables definides amb let. Podem disposar més d’un let si així ho volem.\nPer exemple:\nfor $pais in //mondial/country\n    let $num_ciutats := count($pais/descendant::city)\n    let $tot_pobl := sum($pais/descendant::city/population)\n    let $percent := $tot_pobl div $pais/population\n    ...\nAmb la clàusula where afegirem filtres sobre la llista d’iteració, de manera que els elements del for que no compleixin la condició del where seran omesos en el bucle:\nfor $pais in //mondial/country\n    let $num_ciutats := count($pais/descendant::city)\n    let $tot_pobl := sum($pais/descendant::city/population)\n    let $percent := $tot_pobl div $pais/population\n    where $pais/encompassed/@continent='europe'\n    ...\nAmb la clàusula order by ordenem el resultat del for. Per tant, especifiquem l’ordre de recorregut del bucle:\nfor $pais in //mondial/country\n    let $nom := $pais/name/text()\n    let $num_ciutats := count($pais/descendant::city)\n    let $tot_pobl := sum($pais/descendant::city/population)\n    let $percent := $tot_pobl div $pais/population * 100\n    where $pais/encompassed/@continent='europe'\n    order by $percent ascending\n    ...\nAmb la clàusula return indicarem què s’ha de mostrar com a resultat com a resposta a cada iteració (no a tot el bucle). El resultat ha de ser un únic node XML o una primitiva bàsica (com una cadena o un enter) per a cada iteració executada. El return s’executarà, per tant, n vegades:\nfor $pais in //mondial/country\n    let $nom := $pais/name/text()\n    let $num_ciutats := count($pais/descendant::city)\n    let $tot_pobl := sum($pais/descendant::city/population)\n    let $percent := $tot_pobl div $pais/population * 100\n    where $pais/encompassed/@continent='europe'\n    order by $percent ascending\n    return &lt;pais&gt; {$nom} : {$percent} &lt;/pais&gt;\n\nVegem ara tot un seguit d’exemples de XQuery que demostren algunes particularitats destacables:\n\nNom de les províncies espanyoles:\nfor $p in //mondial/country[name='Spain']/province\n    return $p/name\nExtracció de la llista de ciutats de cada província espanyola:\nfor $p in //mondial/country[name='Spain']/province\n    let $nom := $p/name/text()\n    let $ciutats := string-join($p/city/name, ', ')\n    return &lt;provincia&gt; {$nom}: {$ciutats} &lt;/provincia&gt;\nLlista dels països que tenen més d’un 1% de la població mundial total, ordenats per població descendent i mostrant els resultats en format XML:\nfor $c in //mondial/country\n    let $n := $c/name/text()\n    let $p := $c/population/text()\n    where $p&gt;=sum(//mondial/country/population)*0.01\n    order by number($p) descending\n    return &lt;pais nom='{$n}'&gt;{$p}&lt;/pais&gt;\nNom de les províncies espanyoles, amb població i quantitat de ciutats, ordenats per quantitat de ciutats en ordre descendent, amb resultat en format XML:\nfor $p in //mondial/country[name='Spain']/province\n    let $nom := $p/name\n    let $pop := $p/population\n    let $num := &lt;count&gt; {count($p/city)} &lt;/count&gt;\n    order by $num descending\n    return &lt;provincia&gt; {$nom} {$pop} {$num} &lt;/provincia&gt;\nRedreçament de la informació de les províncies, amb cada província amb atributs de nom i població i llista de ciutats interna, amb una entrada per a cada ciutat:\nfor $p in //mondial/country[name='Spain']/province\n    let $nom := $p/name/text()\n    let $pop := $p/population/text()\n    let $cities := &lt;cities&gt; {\n        for $c in $p/city/name/text() \n            return &lt;city&gt; {$c} &lt;/city&gt;\n        } &lt;/cities&gt;\n    return &lt;provincia nom='{$nom}' population='{$pop}'&gt; {$cities} &lt;/provincia&gt;",
    "crumbs": [
      "Inici",
      "8 XND: XPath/XQuery"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#declaració-de-funcions-en-xquery",
    "href": "posts/2013-07-03-BD08-xnd-xpath-i-xquery/index.html#declaració-de-funcions-en-xquery",
    "title": "XND - XPath i XQuery",
    "section": "5. Declaració de funcions en XQuery",
    "text": "5. Declaració de funcions en XQuery\nÉs possible definir funcions pròpies per a ser utilitzades en les nostres consultes XQuery. La forma de fer-ho és mitjançant la següent sintaxi:\ndeclare function nom_de_la_funció($var1 as tipus, $var2 as tipus, ...) as tipus {\n    ...\n    codi de la funció\n    ...\n}\nXQuery accepta construccions diverses en el bloc de codi, com let, for i fins i tot estructures if ... then ... else ....\nA més, les funcions solen definir-se en un espai de funcions concret. Normalment l’espai serà el local a la consulta (espai de l’usuari). Això es fa indicant el nom de la funció amb una especificació local: prèvia al nom de la funció.\nVegem ara alguns exemples que demostren diferents situacions útils en la construcció de funcions XQuery:\n\nFunció que calcula arrel d’índex N a partir de l’índex i el radicand:\ndeclare function local:sqrtN($i as xs:double, $r as xs:double) as xs:double {\n    let $x := math:pow($r, 1 div $i)\n    return $x\n};\nlocal:sqrtN(3, 125)\nFunció que retorna la primera paraula de la cadena indicada\ndeclare function local:primera-paraula($cad as xs:string) as xs:string {\n    let $paraula := substring-before($cad, ' ')\n    return $paraula\n};\nlocal:primera-paraula('Ola k ase')\nFunció recursiva per al factorial (i exemple de if)\ndeclare function local:factorial($n as xs:integer) as xs:integer {\n    if ($n&lt;=1)\n    then $n\n    else $n*local:factorial($n - 1)\n};\nlocal:factorial(7)\nMarge de població (diferència de població entre el país més habitat i el menys)\ndeclare function local:marge($seq as element()*) as xs:double {\n    let $a := min($seq)\n    let $b := max($seq)\n    return ($b - $a)\n};\nlocal:marge(//mondial/country/population)\nQuantitat de ciutats per país\ndeclare function local:numciutats($c as element(country)*) as xs:double {\n    let $n := count($c/descendant::city)\n    return $n\n};\nlocal:numciutats(//mondial/country[name='Spain'])",
    "crumbs": [
      "Inici",
      "8 XND: XPath/XQuery"
    ]
  },
  {
    "objectID": "posts/2013-04-22-creating-a-new-grub2-background-image/index.html",
    "href": "posts/2013-04-22-creating-a-new-grub2-background-image/index.html",
    "title": "Creating a new Grub2 background image (menu only) in Ubuntu >11.10",
    "section": "",
    "text": "Procedure\nInstall the desktop-base package (if not already installed):\nsudo aptitude install desktop-base\nIf you reboot the system, the boot menu will show an ugly background. Right. We’ll change it!\nFirst, we will prepare the image. Get a photo, search your albums, whatever will serve. We will consider the image as if it will reside on /shared/photos/myphoto.jpg. We will keep the grub version under the same directory and then link with it, so follow the next steps.\nIf your monitor ratio is 16:9, and the original photo is 4:3, you can run the following line in the terminal prompt:\ncd /shared/photos\nconvert myphoto.jpg -resize 600x450 -gravity center -background Black -extent 800x450 myphoto-grub.png\nBut, if your monitor is 16:10, you can run the next variation:\nconvert myphoto.jpg -resize 640x480 -gravity center -background Black -extent 768x480 myphoto-grub.png\nAs you can see, I’ve used the convert command (from ImageMagick), resizing the image to an intermediate size and centering on to the final layout, making the left and right extra bands filled with black.\nAdapt it to your needs: maybe the original image is 16:9 or 16:10 already, or your computer has a 4:3 monitor. In such cases, change the resize part and remove the rest of parameters.\nRemember the bc command to make simple (or not so-simple) calculations:\n$ echo \"scale=10; 450*16/9\" | bc\n800\nIn my case, I have a photo of one of my sons, and I want to put it bottom-right to the menu, bordered and filling with a similar color of its background:\nconvert joan.jpg -resize 120x90 -bordercolor White \\\n-border 1x1 -gravity SouthEast \\\n-background `convert joan.jpg -format \"%[pixel:s.p{0,0}]\" info:` \\\n-extent 800x450 joan_grub.png\nFirst, I resize it to 120x90 (1/5 in the final image height, 4:3 ratio), I enclose it with a white border, and then put it to the bottom-right of the final extent of 800x450. For the background color, I use another convert execution, that extracts the rgb of the pixel at coordinates (0,0) of the original image. Suit yourself to adapt it to what you want.\nIn any case, you now have the image at a good (sufficient) resolution for the boot menu. We’ll reassign the link to that image.\nBy default, the image can be found as /usr/share/images/desktop-base/desktop-grub.png, but this is only a sym-link, so we’ll change the target:\ncd /usr/share/images/desktop-base\nsudo rm desktop-grub.png\nsudo ls -s /shared/photos/myphoto-grub.png desktop-grub.png\nAs you see, we destroy the original link and then recreate it with our own image path.\nIf you want to change the default text colors of the menu, edit the /usr/share/desktop-base/grub_background.sh script:\ngksudo gedit /usr/share/desktop-base/grub_background.sh\nYou can change the two color definition lines:\n\nCOLOR_NORMAL defines the normal color of the menu entries (foreground/background).\nCOLOR_HIGHLIGHT defines the foreground/background colors of the selected entry.\n\nFor example, I want to make the highlighted with yellow color, so I change only that line:\nCOLOR_HIGHLIGHT=yellow/black\nWhen a background image is active, background color doesn’t work, so leave it black, as it doesn’t matter.\nThe color is specified according to RGB codes (“#c3e28a”) or common names (“light-blue”), and are found at theming grub …with lots of other interesting configuration parameters!!!\nAnd finally, we re-run the update-grub script:\nsudo update-grub\nAnd… voilà! Restart the system and enjoy!\n\n\n\nFoto Grub amb en Joan\n\n\nConsider the fact that now your boot-menu background-image is redirected to the path you entered, so you can substitute with another (or edit the image with some image-editing tool), and rerun the update-grub script.\nEasy, simple, direct, right?"
  },
  {
    "objectID": "posts/2013-06-29-BD01-tipus-de-bases-de-dades/index.html",
    "href": "posts/2013-06-29-BD01-tipus-de-bases-de-dades/index.html",
    "title": "Tipus de bases de dades - discusió i ús",
    "section": "",
    "text": "Existeixen diversos tipus de base de dades actualment, cadascun d’ells orientats a optimitzar l’accés a la informació quan la informació pren formes concretes:\n\nBD relacionals: Taula (Relació) + Unió (PK - FK)\nBD orientades a objecte: Magatzem d’objectes\nBD natives XML: Documents i dades estructurades (documents XML)\n\nCadascun d’ells presenta beneficis particulars.\nPer la forma de les dades i l’estructura interna de l’emmagatzematge de la informació, cadascuna d’aquestes modalitats de base de dades presentarà formes específiques d’accés a la informació:\n\nBD relacionals: Connexió per a l’extracció de files i manipulació de dades (execució SQL: SELECT i sentències DML)\nBD relacionals: Mapatge objecte-relacional (1 registre &lt;-&gt; 1 objecte)\nBD orientades a objecte: Manipulació directa d’objectes (1 registre = 1 objecte)\nBD natives XML: Parsers (anàlisi sintàctic del document XML: DOM)\nBD natives XML: Bindings (1 document XML &lt;-&gt; estructura enllaçada d’objectes)\nBD natives XML: Accés a través de API (execució de consultes XPath/XQuery)\n\nDurant el curs anirem veient la majoria d’aquestes tècniques.\nEn la majoria de casos, l’objectiu final és treballar sobre objectes de tipus POJO (Plain Old Java Object), que seran els elements que s’omplen i utilitzen com a magatzem temporal de la informació que la nostra aplicació enviarà i/o gestionarà.\nEn aquest sentit, un bon disseny de les aplicacions força l’ús de tècniques de disseny del software com:\n\nMVC (Model-View-Controller): L’aplicació es divideix en tres parts:\n\nModel: Aquí es tracta l’emmagatzematge de la informació. En aquest nivell implementarem les tècniques que veurem en el present curs (pensem en registres de taules). Pren la forma d’una col·lecció de funcions estil inserir_missatge(...), obtenir_missatge_per_id(...), eliminar_missatge(...), etc.\nView: Serà la tècnica emprada per mostrar formularis i/o informes a l’usuari, i serà aquí on l’usuari iniciarà processos sobre la informació (pensem en un HTML). Normalment seran plantilles o codi generat a través d’algun sistema modern de generació de vistes.\nController: Aquest nivell implementarà la gestió de la informació i la vinculació cap a les vistes que s’hauran de presentar a l’usuari. És la part més important de l’aplicació, perquè aquí és on es prenen decisions. Pren la forma d’una col·lecció de funcions que responen a les accions dels usuaris i tot un seguit de if i crides a funcions que seran invocats en conseqüència.\n\nMulti-tier (n-capes): L’aplicació es divideix en una quantitat indeterminada de capes o nivells (tiers). El model mínim incorporarà 3 capes:\n\nCapa de dades (Data-tier): Gestiona l’accés a la informació. Equival al Model de MVC.\nCapa de negoci (Business-tier): Gestiona quines accions s’han d’efectuar sobre les dades en funció de les accions dels usuaris. Equival (amb matissos) al Controller de MVC.\nCapa de presentació (Presentation-tier): Genera les vistes que seran ofertes als usuaris en resposta de les seves accions. Equval al View de MVC.\n\n\nLes principals diferències entre MVC i Multi-tier són:\n\nEn MVC no és obligatori passar per la capa “Controller”, mentre que en Multi-tier, l’estructura és canònica.\nEn Multi-tier es pot ampliar la quantitat de capes o nivells afegint-ne segons convingui. Per exemple, es podria afegir una capa d’encriptació i una altra d’enviament entre la de negoci i presentació per fer que l’aplicació tingui la part de presentació executada en un equip remot.\n\nSigui com sigui, tant en MVC com en Multi-tier, la capa de gestió de dades pren la forma de col·lecció de funcions que manipulen dades i típicament treballen amb objectes POJO com el següent:\n\n\npackage com.flx.curset.intro.model;\n\npublic class Employee {\n  int id;\n  String firstname;\n  String lastname;\n  ...\n  \n  public Employee(int id, String firstname, String lastname, ...) {\n    this.id = id;\n    this.firstname = firstname;\n    this.lastname = lastname;\n    ...\n  }\n\n  public int getId() { return id; }\n  public String getFirstname() { return firstname; }\n  public String getLastname() { return lastname; }\n  ...\n\n  public void setId(int id) { this.id = id; }\n  public void setFirstname(String firstname) { this.firstname = firstname; }\n  public void setLastname(String lastname) { this.lastname = lastname; }\n  ...\n}\nTot POJO ha de complir els següents requeriments:\n\nRepresenta un objecte útil de dades completament definit i auto-tancat.\nPresenta uns atributs privats que donen valor a l’objecte.\nPresenta mètodes setter i getter per tal de manipular i obtenir la informació de l’objecte.\n\n\n\n\n\n\n\nNota\n\n\n\nÉs recomanable treballar amb paquets per separar de manera adient els objectes de la capa de dades (model de dades) de la resta de l’aplicació. Observi’s el package de l’exemple POJO mostrat.\n\n\nEls diferents models d’accés a dades (BDR, BDOR, BDO, XND, …) permetran l’extracció, inserció i modificació de dades a través d’una col·lecció d’objectes POJO adient.",
    "crumbs": [
      "Inici",
      "1 Tipus de bases de dades"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD01-tipus-de-bases-de-dades/index.html#tipus-de-bases-de-dades",
    "href": "posts/2013-06-29-BD01-tipus-de-bases-de-dades/index.html#tipus-de-bases-de-dades",
    "title": "Tipus de bases de dades - discusió i ús",
    "section": "",
    "text": "Existeixen diversos tipus de base de dades actualment, cadascun d’ells orientats a optimitzar l’accés a la informació quan la informació pren formes concretes:\n\nBD relacionals: Taula (Relació) + Unió (PK - FK)\nBD orientades a objecte: Magatzem d’objectes\nBD natives XML: Documents i dades estructurades (documents XML)\n\nCadascun d’ells presenta beneficis particulars.\nPer la forma de les dades i l’estructura interna de l’emmagatzematge de la informació, cadascuna d’aquestes modalitats de base de dades presentarà formes específiques d’accés a la informació:\n\nBD relacionals: Connexió per a l’extracció de files i manipulació de dades (execució SQL: SELECT i sentències DML)\nBD relacionals: Mapatge objecte-relacional (1 registre &lt;-&gt; 1 objecte)\nBD orientades a objecte: Manipulació directa d’objectes (1 registre = 1 objecte)\nBD natives XML: Parsers (anàlisi sintàctic del document XML: DOM)\nBD natives XML: Bindings (1 document XML &lt;-&gt; estructura enllaçada d’objectes)\nBD natives XML: Accés a través de API (execució de consultes XPath/XQuery)\n\nDurant el curs anirem veient la majoria d’aquestes tècniques.\nEn la majoria de casos, l’objectiu final és treballar sobre objectes de tipus POJO (Plain Old Java Object), que seran els elements que s’omplen i utilitzen com a magatzem temporal de la informació que la nostra aplicació enviarà i/o gestionarà.\nEn aquest sentit, un bon disseny de les aplicacions força l’ús de tècniques de disseny del software com:\n\nMVC (Model-View-Controller): L’aplicació es divideix en tres parts:\n\nModel: Aquí es tracta l’emmagatzematge de la informació. En aquest nivell implementarem les tècniques que veurem en el present curs (pensem en registres de taules). Pren la forma d’una col·lecció de funcions estil inserir_missatge(...), obtenir_missatge_per_id(...), eliminar_missatge(...), etc.\nView: Serà la tècnica emprada per mostrar formularis i/o informes a l’usuari, i serà aquí on l’usuari iniciarà processos sobre la informació (pensem en un HTML). Normalment seran plantilles o codi generat a través d’algun sistema modern de generació de vistes.\nController: Aquest nivell implementarà la gestió de la informació i la vinculació cap a les vistes que s’hauran de presentar a l’usuari. És la part més important de l’aplicació, perquè aquí és on es prenen decisions. Pren la forma d’una col·lecció de funcions que responen a les accions dels usuaris i tot un seguit de if i crides a funcions que seran invocats en conseqüència.\n\nMulti-tier (n-capes): L’aplicació es divideix en una quantitat indeterminada de capes o nivells (tiers). El model mínim incorporarà 3 capes:\n\nCapa de dades (Data-tier): Gestiona l’accés a la informació. Equival al Model de MVC.\nCapa de negoci (Business-tier): Gestiona quines accions s’han d’efectuar sobre les dades en funció de les accions dels usuaris. Equival (amb matissos) al Controller de MVC.\nCapa de presentació (Presentation-tier): Genera les vistes que seran ofertes als usuaris en resposta de les seves accions. Equval al View de MVC.\n\n\nLes principals diferències entre MVC i Multi-tier són:\n\nEn MVC no és obligatori passar per la capa “Controller”, mentre que en Multi-tier, l’estructura és canònica.\nEn Multi-tier es pot ampliar la quantitat de capes o nivells afegint-ne segons convingui. Per exemple, es podria afegir una capa d’encriptació i una altra d’enviament entre la de negoci i presentació per fer que l’aplicació tingui la part de presentació executada en un equip remot.\n\nSigui com sigui, tant en MVC com en Multi-tier, la capa de gestió de dades pren la forma de col·lecció de funcions que manipulen dades i típicament treballen amb objectes POJO com el següent:\n\n\npackage com.flx.curset.intro.model;\n\npublic class Employee {\n  int id;\n  String firstname;\n  String lastname;\n  ...\n  \n  public Employee(int id, String firstname, String lastname, ...) {\n    this.id = id;\n    this.firstname = firstname;\n    this.lastname = lastname;\n    ...\n  }\n\n  public int getId() { return id; }\n  public String getFirstname() { return firstname; }\n  public String getLastname() { return lastname; }\n  ...\n\n  public void setId(int id) { this.id = id; }\n  public void setFirstname(String firstname) { this.firstname = firstname; }\n  public void setLastname(String lastname) { this.lastname = lastname; }\n  ...\n}\nTot POJO ha de complir els següents requeriments:\n\nRepresenta un objecte útil de dades completament definit i auto-tancat.\nPresenta uns atributs privats que donen valor a l’objecte.\nPresenta mètodes setter i getter per tal de manipular i obtenir la informació de l’objecte.\n\n\n\n\n\n\n\nNota\n\n\n\nÉs recomanable treballar amb paquets per separar de manera adient els objectes de la capa de dades (model de dades) de la resta de l’aplicació. Observi’s el package de l’exemple POJO mostrat.\n\n\nEls diferents models d’accés a dades (BDR, BDOR, BDO, XND, …) permetran l’extracció, inserció i modificació de dades a través d’una col·lecció d’objectes POJO adient.",
    "crumbs": [
      "Inici",
      "1 Tipus de bases de dades"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html",
    "title": "JDBC amb SQL",
    "section": "",
    "text": "Els connectors JDBC permeten utilitzar les bases de dades dels fabricants més importants des de les nostres aplicacions Java.\nUn connector JDBC està pensat per a només una família de base de dades. Així doncs, existeix un connector JDBC per a MySQL, un altre per Oracle, un altre per a Microsoft SQL Server, etc.\nEn aquest tema farem proves connectant contra una base de dades MySQL local. S’assumeix disposar del MySQL correctament instal·lat i operatiu.\nÉs responsabilitat del programador descarregar el connector JDBC que s’apliqui a la seva versió de Java i instal·lar-la apropiadament o fer ús de la configuració per defecte en casos com les distribucions de Linux.\nEn concret, si s’utilitza una distribució Ubuntu moderna (les proves presentades aquí estan fetes amb Ubuntu &gt;11.10, amb openjdk versió 6 o 7), podrem instal·lar el connector JDBC per a MySQL simplement escrivint:\n$ sudo aptitude install libmysql-java\nQuan disposem del connector ja instal·lat, l’única diferència respecte a la compilació i execució de programes Java és que, quan executem el programa, si el connector no està copiat al directori de treball, hem d’especificar-lo en la ruta de cerca CLASSPATH. En el cas particular, podrem escriure:\n$ javac LlistatPersones.java\n$ java -cp .:/usr/share/mysql-connector-java.jar LlistatPersones\nCom es veu, l’especificació amb el modificador -cp permet indicar el directori actual (.) i la ubicació de l’arxiu comprimit mysql-connector-java.jar que està en un directori del sistema, separant els camins amb el caràcter “:”.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#connectors-jdbc",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#connectors-jdbc",
    "title": "JDBC amb SQL",
    "section": "",
    "text": "Els connectors JDBC permeten utilitzar les bases de dades dels fabricants més importants des de les nostres aplicacions Java.\nUn connector JDBC està pensat per a només una família de base de dades. Així doncs, existeix un connector JDBC per a MySQL, un altre per Oracle, un altre per a Microsoft SQL Server, etc.\nEn aquest tema farem proves connectant contra una base de dades MySQL local. S’assumeix disposar del MySQL correctament instal·lat i operatiu.\nÉs responsabilitat del programador descarregar el connector JDBC que s’apliqui a la seva versió de Java i instal·lar-la apropiadament o fer ús de la configuració per defecte en casos com les distribucions de Linux.\nEn concret, si s’utilitza una distribució Ubuntu moderna (les proves presentades aquí estan fetes amb Ubuntu &gt;11.10, amb openjdk versió 6 o 7), podrem instal·lar el connector JDBC per a MySQL simplement escrivint:\n$ sudo aptitude install libmysql-java\nQuan disposem del connector ja instal·lat, l’única diferència respecte a la compilació i execució de programes Java és que, quan executem el programa, si el connector no està copiat al directori de treball, hem d’especificar-lo en la ruta de cerca CLASSPATH. En el cas particular, podrem escriure:\n$ javac LlistatPersones.java\n$ java -cp .:/usr/share/mysql-connector-java.jar LlistatPersones\nCom es veu, l’especificació amb el modificador -cp permet indicar el directori actual (.) i la ubicació de l’arxiu comprimit mysql-connector-java.jar que està en un directori del sistema, separant els camins amb el caràcter “:”.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#ús-dels-connectors",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#ús-dels-connectors",
    "title": "JDBC amb SQL",
    "section": "2. Ús dels connectors",
    "text": "2. Ús dels connectors\nEls connectors JDBC requereixen d’un seguit de passos pràctics a l’hora d’usar-se en Java:\n\nInvocar la recerca de la classe relacionada amb el connector. Això es fa amb una crida com la següent:\nClass.forName( \"com.mysql.jdbc.Driver\" );\nAixò dependrà, lògicament, del connector específic que estiguem utilitzant.\nAquest pas podria generar una excepció de classe no trobada que ha de ser atesa.\nObtenir una connexió amb el servidor, utilitzant les credencials adients. Això sol fer-se escrivint una línia com la següent:\nString url = \n    Connection conn = DriverManager.getConnection( \n                \"jdbc:mysql://localhost/hr\",\n                \"hr_user\",\n                \"hr_pass\" );\nCom veu, el primer paràmetre de la crida a la funció conté el nom del servidor (o la IP) i el nom de la base de dades. Després s’indicaran l’usuari i la contrasenya en els altres dos arguments de la crida.\nAquest pas podria generar una excepció d’impossible contactar que ha de ser atesa.\nUn cop tenim una connexió establerta, podem utilitzar-la per a realitzar una consulta. Només cal definir un Statement i executar-lo:\nString sql = \"SELECT * FROM employees\";\nStatement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery( sql );\nL’objecte ResultSet obtingut permetrà recórrer les files de resultat de la consulta executada, així com modificar valors en la taula original, si la consulta és senzilla.\nTambé podem executar ordres SQL d’execució (no consultes) que no generaran taules de resultat. Aquí tindrem ordres SQL com UPDATE, INSERT, DELETE, CREATE TABLE, etc. Per invocar aquest tipus d’ordre SQL només cal fer:\nString sql = \"UPDATE employees SET salary=12345 WHERE employeeId=103\";\nStatement stmt = conn.createStatement();\nstmt.execute( sql );\nS’hauran d’atendre les possibles excepcions de tipus java.sql.SQLException que s’hi puguin produir.\nUn cop hem realitzat totes les tasques necessàries amb una consulta, hem d’alliberar (tancar) la consulta:\nrs.close();    // Si és una consulta SELECT\nstmt.close();\nI quan hem acabat de realitzar totes les tasques amb la base de dades, podrem tancar la connexió establerta amb ella:\nconn.close();",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#sobre-els-resultset",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#sobre-els-resultset",
    "title": "JDBC amb SQL",
    "section": "3. Sobre els ResultSet",
    "text": "3. Sobre els ResultSet\nQuan invoquem una consulta SQL que demani un bolcat de dades (consultes tipus SELECT), hem vist que hem d’invocar el mètode Statement.executeQuery(...).\nAquest mètode ens retorna un objecte de tipus ResultSet que contindrà la taula de resultats de la consulta.\nPer recórrer aquesta taula, ho farem línia a línia (fila a fila), mitjançant una estructura clàssica com la següent:\n...\nResultSet rs = stmt.executeQuery( sql );\nwhile( rs.next() ) {\n  int id = rs.getInt(\"employeeId\");\n  String nom = rs.getString(\"firstname\");\n  String cognoms = rs.getString(\"lastname\");\n  System.out.println( id + \": \" + cognoms + \", \" + nom );\n}\nrs.close();\n...\nObservi que es fa ús de la funció ResultSet.next() per anar recorrent tota la taula de resultats. Amb la fila activa, podem extreure els valors de les columnes fent crides a les funcions ResultSet.getInt(...) o ResultSet.getString(...).\nExisteix tota una col·lecció de funcions en la classe ResultSet que permet recórrer verticalment la taula (moure’s entre les files) com first(), last(), etc.\nDe la mateixa manera existeix tota una col·lecció de mètodes per obtenir les dades en diferents tipus: getInt(), getString(), getDate(), etc.\nIndependentment, també podem modificar els valors de la taula resultant. Això s’analitzarà en un exemple posterior. I és que existeixen mètodes com setInt() o setString() i la funció updateRow() que actualitza la taula en la base de dades original. Amb tot, per utilitzar aquesta funcionalitat, s’ha d’especificar que aquesta consulta sigui de tipus actualitzable.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#execució-de-consultes-de-modificació-de-dades-dml",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#execució-de-consultes-de-modificació-de-dades-dml",
    "title": "JDBC amb SQL",
    "section": "4. Execució de consultes de modificació de dades (DML)",
    "text": "4. Execució de consultes de modificació de dades (DML)\nPer al cas d’executar ordres SQL de manipulació de dades (les que s’anomenen comunament DML), en comptes de fer servir el mètode Statement.executeSQL(...), farem servir Statement.execute(...).\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple de curs número 1.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#modificació-de-dades-des-de-consulta-updatable",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#modificació-de-dades-des-de-consulta-updatable",
    "title": "JDBC amb SQL",
    "section": "5. Modificació de dades des de consulta UPDATABLE",
    "text": "5. Modificació de dades des de consulta UPDATABLE\nPodem modificar les dades directament sobre una consulta de tipus SELECT i després demanar que les dades modificades s’incorporin a l’origen de dades (la taula original). Això permet agilitzar l’accés i modificació de les dades des del programa, sense haver d’executar ordres SQL diverses per a cada operació.\nPer aconseguir-ho hem de realitzar una consulta estàndard de selecció (SELECT), però marcar la consulta com a actualitzable. Aleshores executem la consulta normalment i rebem el resultat del SELECT en un objecte ResultSet com abans.\nLa diferència és que mentre recorrem la taula de dades obtinguda, podem executar mètodes de modificació d’aquestes dades amb crides a ResultSet.updateInt(...) o ResultSet.updateString(...), per exemple.\nUn cop hem realitzat totes les modificacions que necessitem, simplement executarem ResultSet.updateRow() per enregistrar els canvis de la fila modificada en la taula original de la base de dades:\n...\nString sql = \"SELECT * FROM employees\";\nStatement stmt = conn.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE,\n                                       ResultSet.CONCUR_UPDATABLE );\nResultSet rs = stmt.executeQuery( sql );\nwhile( rs.next() ) {\n  float salary  = rs.getFloat( \"salary\" );\n  if ( salary &lt; 10000 ) salary *= 1.03;\n  else salary *= 1.035;\n  rs.updateFloat( \"salary\", salary );\n  rs.updateRow();\n}\nrs.close();\nstmt.close();\n...\nEls canvis són incorporats immediatament a la base de dades i són accessibles a posteriors consultes de selecció.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#preparació-de-consultes-amb-preparestatement",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#preparació-de-consultes-amb-preparestatement",
    "title": "JDBC amb SQL",
    "section": "6. Preparació de consultes amb prepareStatement()",
    "text": "6. Preparació de consultes amb prepareStatement()\nPodem configurar consultes parametritzades de qualsevol tipus (selecció, DML, etc.), és a dir, construir consultes que reben dades provinents de variables de Java que incorporem a la sentència.\nPer fer-ho, Java ens ofereix la classe PreparedStatement que funciona exactament igual que Statement des del punt de vista de l’execució de sentències SQL, però que accepta la parametrització de la consulta.\nObservi el següent exemple:\nPreparedStatement pstmt = conn.prepareStatement(\n    \"SELECT COUNT(*) AS total FROM employees WHERE firstname=? AND lastname=?\" );\npstmt.setString( 1, firstname );\npstmt.setString( 2, lastname );\nResultSet rs = pstmt.executeQuery();\n...\nVeurà que la consulta SQL, ara construïda sobre un objecte de tipus PreparedStatement i obtinguda amb una crida a Connection.prepareStatement(...), rep una cadena SQL convencional on s’han omès l’usuari i la contrasenya, i s’ha escrit en el seu lloc un caràcter ?. Observi que tampoc hi ha cometes simples ni dobles encerclant l’interrogant.\nDesprés es canvien els interrogants fent crides a PreparedStatement.setString(...) per modificar les dades en les posicions 1 i 2 (així és com fem referència als interrogants).",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#extracció-de-les-metadates-de-la-consulta",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#extracció-de-les-metadates-de-la-consulta",
    "title": "JDBC amb SQL",
    "section": "7. Extracció de les metadates de la consulta",
    "text": "7. Extracció de les metadates de la consulta\nTota consulta, un cop executada, genera un objecte ResultSet amb les dades obtingudes. Però si necessitem saber quantes columnes hem obtingut i quins són els seus tipus de dada, haurem d’accedir al que s’anomena les metadates del ResultSet.\nPer obtenir les metadates, simplement haurem d’executar una crida a la funció ResultSet.getMetaData() sobre el ResultSet obtingut de la consulta i obtindrem un objecte ResultSetMetaData amb la informació:\nResultSetMetaData rsmd = rs.getMetaData();\nAmb aquest objecte podem descobrir moltes característiques relacionades amb les columnes obtingudes en aquell ResultSet:\n\nAmb ResultSetMetaData.getColumnCount() obtindrem la quantitat de columnes obtingudes\nAmb ResultSetMetaData.getColumnName(idx) obtindrem el nom (o àlies) associat a la columna indicada numèricament. I tingui present que comença a comptar a partir de 1.\nAmb ResultSetMetaData.getColumnDisplaySize(idx) obtindrem la mida màxima de totes les dades d’aquella columna, permetent, per exemple, saber l’amplada de columna que s’haurà de deixar per pantalla per mostrar tota la taula correctament.\nAmb ResultSetMetaData.getColumnTypeName(idx) obtindrem el tipus de dada de la columna demanada, sent normalment cadenes en nomenclatura MySQL: “INTEGER”, “DATE”, “CHAR”, etc.\n\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple de curs número 2.\n\n\nSi investiga el codi font, veurà que s’ha incorporat la decisió de justificar a esquerra o dreta el text obtingut a partir del tipus de dada de cada columna, i mitjançant crides a les funcions padLeft() i padRight() definides al programa.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#dao-components-daccés-a-dades",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#dao-components-daccés-a-dades",
    "title": "JDBC amb SQL",
    "section": "8. DAO (Components d’accés a dades)",
    "text": "8. DAO (Components d’accés a dades)\nUn component d’accés a dades (DAO, Data Access Object) és un mecanisme de disseny de software àmpliament utilitzat en el desenvolupament de programari.\nParteix de la idea que, en realitat, quan volem disposar de diferents objectes que es vinculin amb orígens de dades, poden existir múltiples mecanismes de persistència.\nVeurem més endavant que JPA (Java Persistence API) ens proveeix d’un mecanisme apte per a realitzar l’abstracció de classes POJO cap a un motor de dades determinat. I fins i tot utilitzarem Hibernate com a intermediari per a construir aplicacions sobre JPA.\nHibernate ens oferirà el mecanisme ideal per al disseny d’una aplicació que connecti contra un motor de base de dades específic, i construïrem l’aplicació en funció del motor triat. Bé, en tot cas configurem Hibernate per treballar amb l’origen de dades específic (nom del servidor de base de dades, port de servei, nom d’usuari, contrasenya).\nA més, hem de disposar d’un connector JDBC específic per al motor concret que utilitzem.\nTot aquest castell de cartes és útil i funciona, però no és l’únic patró de disseny que es fa en l’actualitat.\n\n8.1. Arquitectura n-tier (programació per capes)\nEn l’àmbit de l’enginyeria del software, l’arquitectura multi-capa (multi-tier architecture) (també coneguda com a “arquitectura n-tier” és un arquitectura de disseny de programació que consta de tres capes o elements separats des del punt de vista lògic.\nL’arquitectura més habitual és la de tres capes (3-tier):\n\nPresentació (presentation layer)\nProcessament de l’aplicació, també coneguda com a capa de lògica de negoci (logical/business layer)\nFuncions de manipulació de dades (data layer)\n\nAquesta arquitectura de disseny ens permet construir aplicacions on cadascun dels elements pugui ser desenvolupat separadament, o substituït completament, sense haver de modificar res de cap de les altres capes. Per exemple, en cas d’un canvi de sistema operatiu només caldrà adequar la capa de presentació, o si es canvia el sistema d’emmagatzematge de dades només s’haurà de canviar la capa de dades.\nL’estructura de tres capes va ser desenvolupada originàriament per John J. Donovan en Open Environment Corporation (OEC) a Cambridge, Massachusetts.\n\n\n\nAspecte general d’una aplicació 3-tier\n\n\n\n\n8.2. Capa de presentació (Presentation tier)\nÉs la capa més alta de l’aplicació. Mostra la informació a l’usuari com a resultat de les accions que realitza i les dades que demana. Comunica amb la capa de lògica de negoci com a resposta de les accions dels usuaris.\nComunament serà una pàgina web o la pantalla principal i els formularis secundaris d’una aplicació de plataforma.\n\n\n8.3. Capa de lògica de negoci (Logical/Business tier)\nAquesta capa controla realment la funcionalitat de l’aplicació, realitzar el processament detallat de les accions demanades per l’usuari a la capa de presentació, enviant o rebent dades de la capa de dades situada per sota.\n\n\n8.4. Capa de dades (Data tier)\nAquesta capa consisteix en la connexió amb els servidors de bases de dades i/o orígens d’informació i dades. Aquí és on s’obté i processa la informació. Aquesta capa manté les dades d’una manera neutral i independent de l’aplicació i la lògica de l’aplicació.\nFer aquesta separació permet l’escalabilitat i la millora de l’eficiència de les aplicacions, a més de permetre l’existència (i potser coexistència simultània) de diversos orígens de dades.\n\n\n8.5. Comparació amb l’arquitectura MVC\nL’arquitectura MVC (Model-View-Controller) és un model de tres capes semblant al presentat fins ara, però que incorpora una petita diferència: en el cas de MVC, la comunicació entre capes pot realitzar-se directament entre la capa de dades (model) i la de presentació (vista); mentre que en el cas 3-tier, no és permesa la comunicació entre dades i presentació (sempre s’ha de passar a través de la capa de processament).\n\n\n8.6. Concepte de DAO\nEvidentment no és temari d’aquest tema (ni d’aquest curs com a conjunt) parlar de les capes de presentació i de processament. Del que sí hem de parlar és de la capa d’accés a dades (DAL, Data Access Layer).\nAquesta capa, tal i com s’ha esmentat, és l’encarregada de la persistència de dades en els medis i amb els mitjans requerits i/o disponibles per al correcte funcionament de l’aplicació.\nAixò es desglossa en diversos tipus d’implementació que dependran del model de dades triat. Aquests models poden ser combinats i en poden haver més d’un en una mateixa aplicació.\nEls models de dades més utilitzats avui dia són:\n\nFitxers de disc, amb formats estàndard coneguts i/o propietaris\nDades residents en bases de dades relacionals\nDades residents en bases de dades orientades a objectes\nDocuments residents en una bases de dades natives XML\n\nLa metodologia utilitzada comunament per implementar la capa d’accés a dades (DAL) és la de construir una col·lecció d’objectes (tot sovint a través d’interfícies) que representin objectes que permetin accedir a la informació ubicada en aquells dipòsits d’informació.\nAquests objectes, coneguts com a objectes d’accés a dades (DAO, Data Access Objects), són en realitat l’objectiu d’aquesta unitat formativa.\n\n\n\n\n\n\nNota\n\n\n\nUn DAO és un objecte POJO que representa una unitat d’informació tancada des d’un punt de vista conceptual, i que implementa les operacions CRUD a més d’altres mètodes més específics d’objecte específic.\n\n\nLes operacions CRUD són les habituals de tot element d’informació: Create, Read, Update i Delete (crear, llegir, editar i eliminar).\nEn una aplicació, hi ha tants DAO com models. És a dir, en una base de dades relacional, per cada taula haurà un DAO associat (tot i que un sol DAO pot cobrir més d’una taula o entitat).\nL’avantatge d’usar DAO és la separació senzilla però rigorosa entre les parts d’una aplicació que preferiblement haurien de ser independents unes d’altres, i que poden evolucionar o canviar separadament. Així doncs, es podria canviar la lògica de negoci d’una aplicació sense tocar ni una sola línia de codi de les interfícies DAO, i viceversa. Igual respecte a la capa de presentació.\nEls seus grans avantatges són:\n\nPot ser usat en un gran nombre d’aplicacions, allà on es requereixi d’un magatzem d’informació.\nAmaguen els detalls de la implementació de l’emmagatzematge de la resta de l’aplicació.\nActuen com a intermediari entre l’aplicació i la base de dades. Mouen dades entre els objectes i els orígens d’informació.\nPermeten que els canvis en els mecanismes de persistència no afectin moltes àrees de l’aplicació.\n\nDes del punt de vista específica del llenguatge Java, els DAO poden implementar-se de moltes maneres: des de simples interfícies que separen l’accés a dades de la lògica de l’aplicació; fins a llibreries i productes comercials: JPA, JDO, Enterprise Java Beans (J2EE), TopLink, Doctrine, Hibernate, iBATIS, Apache OpenJPA, etc.\nL’ús de DAO en entorns Java hauria de comportar:\n\nUn augment de l’eficiència i rendiment de la capa de dades, perquè ara es torna reutilitzable, i\nCapacitat de modificar els DAO sense alterar altres parts de l’aplicació.\n\nDe vegades necessitarem també dels DTO (Data Transfer Object), també denominats VO (Value Object). Són utilitzats pels DAO per a transportar les dades des de la base de dades fins a la capa de lògica de negoci i viceversa. Malgrat això, normalment són els mateixos DAO que són moguts des de i cap a la capa de lògica.\nEl patró de disseny DAO consisteix en algunes classes factoria, interfícies DAO i algunes classes DAO que implementin aquelles interfícies:\n\n\n\nModel DAO\n\n\nEls DAO són els objectes primaris d’aquest patró de disseny. Aquest objecte abstreu la implementació d’accés a dades dels altres objectes per habilitar l’accés transparent a la base de dades o unitat d’emmagatzematge.\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple de curs número 3.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#problemàtica-del-jdbc",
    "href": "posts/2013-06-29-BD02-jdbc-amb-sql/index.html#problemàtica-del-jdbc",
    "title": "JDBC amb SQL",
    "section": "9. Problemàtica del JDBC",
    "text": "9. Problemàtica del JDBC\nQuè passa si, mitjançant l’exemple número 3, intenta aplicar el procés de canvi de sou al treballador amb employeeId=100?\nLa solució és fer que els POJO no facin referència als id d’altres taules, sinó que les referències entre taules es resolguin directament a objectes de les classes associades.\nAixí doncs, el POJO Employee hauria de ser així:\npublic class Employee {\n  int employeeId;\n  String firstname;\n  String lastname;\n  String email;\n  String phoneINT;\n  Date hireDate;\n  Job job;\n  float salary;\n  float commissionPct;\n  Employee manager;\n  Department department;\n  ...\n}\nObservi que ara aquells camps que són clau forana a altres taules han estat substituïts per objectes referenciats adecuadament des d’aquest. Així, si tenim un determinat treballador e1, si apliquem e1.getDepartment() el que obtindríem seria tot un objecte de la classe Department amb què podrem treballar normalment.\nAquesta idea, que resulta evident ara que ha estat presentada, incorpora una gran problemàtica si intenta dur-se a terme amb simples consultes SQL a través de JDBC. Els motius són diversos:\n\nHauríem de mantenir en memòria gran part (o tota) la base de dades, perquè un treballador tindrà un cap, que al seu torn tindrà un altre, etc. El mateix amb la resta d’elements de la base de dades.\nHem d’escriure moltíssimes línies de codi per obtenir pocs (o cap) avantatges només per tenir els objectes en memòria.\nUn canvi en les dades no és reflectit en la base de dades de cap manera. Hauríem de programar una funció que bolqués les dades de nou a la taula atenent als canvis que s’hi descobreixin, fent també el programa molt més complex i llarg.\nLes dades quedaran desactualitzades si la base de dades canvia la informació de les taules degut a l’execució d’ordres SQL provinents d’altres programes i/o usuaris concurrents. Això no podem atacar-ho d’una manera neta i definitiva, sent un greu problema en el disseny de la base de dades i el seu ús.\n\nPer tant, fora de programes que accedeixen a la informació de manera immediata, realitzen llistats o executen ordres SQL de gestió de la informació, l’ús de JDBC queda lluny de ser solució en una manipulació intensiva i continuada de les dades de la base de dades, on el programa hagi d’accedir a blocs d’informació amplis i treballar en paral·lel amb multitud de taules i usuaris concurrents.\nVeurem, com a solució, altres tècniques al llarg d’aquest curs. Bàsicament mitjançat JPA i Hibernate.",
    "crumbs": [
      "Inici",
      "2 JDBC amb SQL"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html",
    "href": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html",
    "title": "XND, BaseX i Java",
    "section": "",
    "text": "És evident que una base de dades nativa XML (XND a partir d’ara) no és el mateix que una base de dades relacional (BDR a partir d’ara). El magatzem de dades és diferent, tant en estructuració lògica com física:\n\nDes d’un punt de vista lògic, el model de la base de dades és diferent en cada cas: en el cas de BDR la informació es disposa en taules que representen unitats (entitats) i s’estableixen relacions entre dites entitats. En el cas de XND, la informació es disposa en unes estructures jeràrquiques on la informació ja es mostra relacionada, tota entremesclada i resolta. Potser hem de vincular certes parts d’aquests arbres jeràrquics, però la idea és minimitzar aquest tipus de resolucions.\nDes d’un punt de vista físic, els arxius que representen les dades estan estructurats de manera diferent, perquè en el cas de les bases de dades BDR el mateix SGBDR (Sistema Gestor de B.D. relacional) construeix i manté les codificacions i estructures internes dels arxius involucrats, tot decidint si una taula de dades ha d’estar partida en un o més arxius, o si aquest partiment es realitza dins d’un únic arxiu combinant múltiples objectes o no. En una XND, pel contrari, l’emmagatzematge és una col·lecció d’arxius XML que poden ser editats i consultats per altres mitjans, i no només a través de l’accés per XND.\n\nÉs per això que ara la concepció del “servidor de base de dades” també canviarà, i és que ara només s’ha d’encarregar de manipular un o més arxius XML, realitzant consultes i algunes modificacions puntuals. Vist així, la base de dades XND pren més la forma d’un mòdul ple de funcions que no un servidor en el sentit tradicional del terme.\nTot i això, certs productes XND prenen la forma de mòdul o llibreria, mentre que d’altres prenen la forma de servei de xarxa:\n\nXND com a llibreria: Aquí, l’accés i manipulació de la informació no requereix d’una connexió de xarxa, sinó que la llibreria implementa l’accés controlat a les dades de la base de dades XND a través de classes i/o funcions.\nXND a través de connexió de xarxa: Seguint el model tradicional, la base de dades XND disposa d’una aplicació servidor que, en ser iniciada, obre un port i permet connexions locals i/o remotes per atendre peticions d’accés sobre la base de dades.\n\nEn el cas de BaseX que estudiem, el model utilitzat és el segon i existeix un servidor que ofereix el servei de xarxa per accedir a la base de dades XND.\nEn concret, BaseX ens ofereix els següent mecanismes per operar amb la base de dades:\n\nUna aplicació gràfica que connecta directament amb la base de dades: basexgui\nUna aplicació de consola que connecta directament amb la base de dades: basex\nUn servidor que obre un port i accepta connexions remotes: basexserver\nUn client de consola que connecta amb un servidor BaseX remot per executar-hi ordres: basexclient\n\nEl que ens interessa aquí és basexserver que, en ser iniciat, obre un port d’accés que permet la interacció amb el servidor de la manera tradicional gràcies a connexions remotes o locals a través del subsistema de xarxa.\nPer tant, necessitem iniciar el servidor, i això ho fem des de la consola escrivint el nom de l’ordre del servidor.\nTambé podem iniciar-lo en mode daemon escrivint:\nbasexserver -S\nUn cop iniciat el servidor, podem realitzar connexions amb ell des del client basexclient o des de llenguatges de programació com farem nosaltres des de Java.\nSi mai hem d’aturar el servidor manualment, ho farem mitjançant l’ordre de consola:\nbasexserver stop\nSi hem de fer proves des d’un client remot al servidor amb què volem connectar, necessitarem iniciar sessió remota. Així, per exemple, per connectar amb un servidor BaseX en marxa situat a una IP 192.168.1.1, amb usuari “usuari” i contrasenya “1234”, simplement hem d’escriure:\nbasexclient -n192.168.1.1 -Uusuari -P1234\nAixí iniciarem una sessió interactiva per executar ordres sobre el servidor XND.\nD’igual manera, per realitzar tasques sobre el servidor XND, però des de llenguatges d’alt nivell com Java, necessitarem algun tipus de llibreria que ens ofereixi la infraestructura per a connectar, tot especificant també la IP, el nom d’usuari i la contrasenya d’aquell usuari.\nUn cop iniciada una sessió d’execució d’ordres, BaseX és molt semblant a qualsevol altre sistema servidor, tot i que el seu llenguatge té característiques pròpies.",
    "crumbs": [
      "Inici",
      "9 XND: BaseX+Java"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html#connexió-amb-bases-de-dades-natives-xml",
    "href": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html#connexió-amb-bases-de-dades-natives-xml",
    "title": "XND, BaseX i Java",
    "section": "",
    "text": "És evident que una base de dades nativa XML (XND a partir d’ara) no és el mateix que una base de dades relacional (BDR a partir d’ara). El magatzem de dades és diferent, tant en estructuració lògica com física:\n\nDes d’un punt de vista lògic, el model de la base de dades és diferent en cada cas: en el cas de BDR la informació es disposa en taules que representen unitats (entitats) i s’estableixen relacions entre dites entitats. En el cas de XND, la informació es disposa en unes estructures jeràrquiques on la informació ja es mostra relacionada, tota entremesclada i resolta. Potser hem de vincular certes parts d’aquests arbres jeràrquics, però la idea és minimitzar aquest tipus de resolucions.\nDes d’un punt de vista físic, els arxius que representen les dades estan estructurats de manera diferent, perquè en el cas de les bases de dades BDR el mateix SGBDR (Sistema Gestor de B.D. relacional) construeix i manté les codificacions i estructures internes dels arxius involucrats, tot decidint si una taula de dades ha d’estar partida en un o més arxius, o si aquest partiment es realitza dins d’un únic arxiu combinant múltiples objectes o no. En una XND, pel contrari, l’emmagatzematge és una col·lecció d’arxius XML que poden ser editats i consultats per altres mitjans, i no només a través de l’accés per XND.\n\nÉs per això que ara la concepció del “servidor de base de dades” també canviarà, i és que ara només s’ha d’encarregar de manipular un o més arxius XML, realitzant consultes i algunes modificacions puntuals. Vist així, la base de dades XND pren més la forma d’un mòdul ple de funcions que no un servidor en el sentit tradicional del terme.\nTot i això, certs productes XND prenen la forma de mòdul o llibreria, mentre que d’altres prenen la forma de servei de xarxa:\n\nXND com a llibreria: Aquí, l’accés i manipulació de la informació no requereix d’una connexió de xarxa, sinó que la llibreria implementa l’accés controlat a les dades de la base de dades XND a través de classes i/o funcions.\nXND a través de connexió de xarxa: Seguint el model tradicional, la base de dades XND disposa d’una aplicació servidor que, en ser iniciada, obre un port i permet connexions locals i/o remotes per atendre peticions d’accés sobre la base de dades.\n\nEn el cas de BaseX que estudiem, el model utilitzat és el segon i existeix un servidor que ofereix el servei de xarxa per accedir a la base de dades XND.\nEn concret, BaseX ens ofereix els següent mecanismes per operar amb la base de dades:\n\nUna aplicació gràfica que connecta directament amb la base de dades: basexgui\nUna aplicació de consola que connecta directament amb la base de dades: basex\nUn servidor que obre un port i accepta connexions remotes: basexserver\nUn client de consola que connecta amb un servidor BaseX remot per executar-hi ordres: basexclient\n\nEl que ens interessa aquí és basexserver que, en ser iniciat, obre un port d’accés que permet la interacció amb el servidor de la manera tradicional gràcies a connexions remotes o locals a través del subsistema de xarxa.\nPer tant, necessitem iniciar el servidor, i això ho fem des de la consola escrivint el nom de l’ordre del servidor.\nTambé podem iniciar-lo en mode daemon escrivint:\nbasexserver -S\nUn cop iniciat el servidor, podem realitzar connexions amb ell des del client basexclient o des de llenguatges de programació com farem nosaltres des de Java.\nSi mai hem d’aturar el servidor manualment, ho farem mitjançant l’ordre de consola:\nbasexserver stop\nSi hem de fer proves des d’un client remot al servidor amb què volem connectar, necessitarem iniciar sessió remota. Així, per exemple, per connectar amb un servidor BaseX en marxa situat a una IP 192.168.1.1, amb usuari “usuari” i contrasenya “1234”, simplement hem d’escriure:\nbasexclient -n192.168.1.1 -Uusuari -P1234\nAixí iniciarem una sessió interactiva per executar ordres sobre el servidor XND.\nD’igual manera, per realitzar tasques sobre el servidor XND, però des de llenguatges d’alt nivell com Java, necessitarem algun tipus de llibreria que ens ofereixi la infraestructura per a connectar, tot especificant també la IP, el nom d’usuari i la contrasenya d’aquell usuari.\nUn cop iniciada una sessió d’execució d’ordres, BaseX és molt semblant a qualsevol altre sistema servidor, tot i que el seu llenguatge té característiques pròpies.",
    "crumbs": [
      "Inici",
      "9 XND: BaseX+Java"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html#gestió-bàsica-duna-base-de-dades-basex",
    "href": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html#gestió-bàsica-duna-base-de-dades-basex",
    "title": "XND, BaseX i Java",
    "section": "2. Gestió bàsica d’una base de dades BaseX",
    "text": "2. Gestió bàsica d’una base de dades BaseX\nVeurem aquí tot un seguit d’ordres que són importants per entendre l’operativa bàsica amb bases de dades XND en la seva implementació pròpia BaseX.\nEls exemples i passos mostrats són tots des del client basexclient, assumint que un servidor basexserver està en execució i que estem connectats amb un usuari amb prou privilegis com per fer les operacions aquí indicades.\nTingui present que, tot just instal·lat, BaseX configura un usuari amb nom “admin” i contrasenya “admin”, de manera que podem connectar amb dit usuari per iniciar la interacció amb el servidor. Si ho fem en la mateixa màquina que el servidor, no cal indicar res a la línia d’ordres.\nA més, es recomana utilitzar el wrapper rlwrap per fer que l’execució de l’ordre sigui més còmoda (memòria de línies antigues, correcte funcionament de les fletxes del cursor, etc.):\n$ rlwrap basexclient\nUsername: admin\nPassword: admin\nBaseX 7.0.2 [Client]\nTry \"help\" to get more information.\n\n&gt; \nLes ordres que accepta BaseX des d’aquesta interfície són moltes i de natura molt variada:\n&gt; help\nTry \"help [...]\" to get info on a specific command.\n\nADD (TO [path]) [input]\n    Add document to database.\nALTER [DATABASE|USER] [...]\n    Alter database name or user password.\nCHECK [input]\n    Open or create database.\nCLOSE \n    Close current database.\nCOPY [name] [newname]\n    Copy database.\nCREATE [BACKUP|DATABASE|EVENT|INDEX|USER] [...]\n    Create database, index or user.\nCS [query]\n    Run XQuery and set result as new context set.\nDELETE [path]\n    Delete documents from database.\nDROP [BACKUP|DATABASE||EVENTINDEX|USER] [...]\n    Drop database, index or user.\nEXIT \n    Exit application.\nEXPORT [path]\n    Export database to XML.\nFIND [keywords]\n    Run a keyword query.\nFLUSH \n    Flush database.\nGET [option]\n    Show global option.\nGRANT [NONE|READ|WRITE|CREATE|ADMIN] (ON [database]) TO [user]\n    Grant user permissions.\nHELP ([command])\n    Get help on BaseX commands.\nINFO ([DATABASE|INDEX|STORAGE])\n    Show information on current database.\nKILL [name]\n    Kill user sessions.\nLIST ([path])\n    List databases or documents in database.\nOPEN [path]\n    Open database.\nOPTIMIZE (ALL)\n    Optimize the database.\nPASSWORD ([password])\n    Change password.\nRENAME [path] [newpath]\n    Rename document paths in database.\nREPLACE [path] [input]\n    Replace documents in database.\nREPO [DELETE|INSTALL|LIST]\n    Install, delete or list packages.\nRESTORE [name-(date)]\n    Restore database.\nRETRIEVE [path]\n    Retrieve raw data.\nRUN [path]\n    Run file as XQuery.\nSET [option] ([value])\n    Set global options.\nSHOW [BACKUPS|DATABASES|EVENTS|SESSIONS|USERS]\n    Show server information.\nSTORE (TO [path]) [input]\n    Store raw data.\nXQUERY [query]\n    Run XQuery.\nTractarem ara les més destacables, tot agrupant-les en diversos grups:\n\nOrdres de gestió de bases de dades\nOrdres de gestió d’usuaris\nOrdres de gestió de privilegis\nOrdres relacionades amb les còpies de seguretat\nOrdres relacionats amb els índexs\nOrdres relacionats amb les consultes de dades\n\n\n2.1. Gestió de bases de dades\nPodem manipular les bases de dades existents amb totes les ordres que ens ofereix BaseX al respecte, i que no són poques:\n\n\n\n\n\n\n\nOrdre\nDescripció\n\n\n\n\nADD (TO [path]) [input]\nAfegir el document a la base de dades\n\n\nALTER DATABASE [...]\nModificar el nom de la base de dades\n\n\nCHECK [input]\nObre o crea una base de dades\n\n\nCLOSE\nTanca la base de dades oberta actualment\n\n\nCOPY [name] [newname]\nCopia la base de dades\n\n\nCREATE DATABASE [...]\nCrea una base de dades nova\n\n\nDELETE [path]\nElimina documents de la base de dades\n\n\nDROP DATABASE\nElimina una base de dades sencera\n\n\nEXPORT [path]\nExporta la base de dades a un arxiu XML\n\n\nFLUSH\nFixa els canvis pendents a la base de dades\n\n\nINFO DATABASE\nMostra informació de la base de dades activa\n\n\nLIST ([path])\nLlista bases de dades i/o documents\n\n\nOPEN [path]\nObre una base de dades\n\n\nOPTIMIZE (ALL)\nOptimitza la base de dades\n\n\nRENAME [path] [newpath]\nCanviar camins a arxius de la base de dades\n\n\nREPLACE [path] [input]\nSubstitueix documents de la base de dades\n\n\nSHOW DATABASES\nMostra informació sobre les bases de dades existents\n\n\n\nObservi les següents ordres que mostren l’ús bàsic d’una sessió d’administració de base de dades XND:\n$ rlwrap basexclient\nUsername: admin\nPassword: admin\nBaseX 7.0.2 [Client]\nTry \"help\" to get more information.\n\n&gt; CREATE DATABASE mondial ./mondial.xml\nDatabase 'mondial' created in 1816.36 ms.\n&gt; CLOSE\nDatabase 'mondial' was closed.\n&gt; SHOW DATABASES\n0 opened database(s).\n&gt; LIST\nName     Resources  Size     Input Path               \n----------------------------------------------------\nmondial  1          2165975  /home/felix/mondial.xml  \ntest     2          4645     /home/felix/testDB       \n\n2 Databases.\n&gt; OPEN mondial\nDatabase 'mondial' opened in 7.47 ms.\n&gt; CREATE DATABASE prova\nDatabase 'prova' created in 44.56 ms.\n&gt; ADD mondial.xml\nPath \"mondial.xml\" added in 1125.91 ms.\n&gt; LIST prova\nInput Path   Type  Content-Type     Size   \n-----------------------------------------\nmondial.xml  xml   application/xml  89486  \n\n1 Resources.\n&gt; INFO\nGeneral Information\n    Version: 7.0.2\n    Database Path: /home/felix/BaseXData\n    Used Main Memory: 1558 KB\n\nResource Properties\n    Whitespace Chopping: ON\n\nIndexes\n    Path Summary: ON\n    Text Index: ON\n    Attribute Index: ON\n    Full-Text Index: OFF\n&gt; INFO DATABASE\nDatabase Properties\n    Name: prova\n    Size: 1839 KB\n    Nodes: 89486\n    Resources: 1\n    Timestamp: 12.03.2013 08:36:02\n\nResource Properties\n    Timestamp: 12.03.2013 08:36:20\n    Encoding: UTF-8\n    Whitespace Chopping: ON\n\nIndexes\n    Up-to-date: false\n    Path Summary: ON\n    Text Index: OFF\n    Attribute Index: OFF\n    Full-Text Index: OFF\n&gt; OPTIMIZE\nDatabase 'prova' optimized in 548.67 ms.\n\n\n2.2. Gestió d’usuaris\nLes ordres relacionades amb la gestió dels usuaris són les següents:\n\n\n\nOrdre\nDescripció\n\n\n\n\nALTER USER [...]\nAlter user password\n\n\nCREATE USER [...]\nCreateuser\n\n\nDROP USER [...]\nDrop user\n\n\nKILL [name]\nKill user sessions\n\n\nPASSWORD ([password])\nChange password\n\n\n\nLes ordres mostrades permeten una gestió simple però efectiva dels usuaris. Observi aquests exemples d’ús:\n\nPrimer de tot definirem un usuari nou anomenat “usuari” amb contrasenya “1234”. Per introduir la contrasenya directament en línia d’ordres de BaseX necessitem calcular el hash MD5 de la contrasenya, perquè ens requereix introduir-la d’aquesta manera. Per tant, primer obtindrem la contrasenya des de consola amb l’eina md5sum:\n$ echo -n \"1234\" | md5sum\n81dc9bdb52d04dc20036dbd8313ed055  -\nI aleshores entrem amb l’usuari administrador i creem efectivament l’usuari:\n$ rlwrap basexclient\nUsername: admin\nPassword: admin\nBaseX 7.0.2 [Client]\nTry \"help\" to get more information.\n\n&gt; CREATE USER usuari 81dc9bdb52d04dc20036dbd8313ed055\nUser 'usuari' created.\n&gt; EXIT\nEnjoy life.\nAra intentem comprovar si l’usuari creat pot iniciar sessió:\n$ rlwrap basexclient\nUsername: usuari\nPassword: 1234\nBaseX 7.0.2 [Client]\nTry \"help\" to get more information.\n\n&gt; OPEN prova\nREAD permission needed.\n&gt; EXIT\nSee you.\nCom veu, es pot iniciar sessió, però no es tenen privilegis d’accés a cap base de dades (més endavant es veurà com modificar privilegis).\nAra definirem un altre usuari que voldrem que sigui administrador de la base de dades i algun altre usuari:\n$ rlwrap basexclient\nUsername: ·admin\nPassword: ·admin\nBaseX 7.0.2 [Client]\nTry \"help\" to get more information.\n\n&gt; CREATE USER admin2 \nPassword: ·1234\nUser 'admin2' created.\n&gt; ALTER USER admin2 \nPassword: ·jA7sh$12@\nPassword of user 'admin2' changed.\n&gt; CREATE USER alu01 81dc9bdb52d04dc20036dbd8313ed055\nUser 'alu01' created.\n&gt; CREATE USER alu02 81dc9bdb52d04dc20036dbd8313ed055\nUser 'alu02' created.\n&gt; CREATE USER alu03 81dc9bdb52d04dc20036dbd8313ed055\nUser 'alu03' created.\n&gt; CREATE USER alu04 81dc9bdb52d04dc20036dbd8313ed055\nUser 'alu04' created.\n&gt; CREATE USER alu05 81dc9bdb52d04dc20036dbd8313ed055\nUser 'alu05' created.\n&gt; CREATE USER alu06 81dc9bdb52d04dc20036dbd8313ed055\nUser 'alu06' created.\nCom veu, es mostra com hem de canviar una contrasenya d’un usuari existent, a més de com introduir-la sense que es vegi per pantalla.\nEliminem un usuari que sobra:\n&gt; DROP USER alu06\nUser 'alu06' dropped.\n\n\n\n2.3. Gestió de privilegis\nLa gestió de privilegis en BaseX és força senzilla. En concret, incorpora 5 privilegis que poden aplicar-se sobre qualsevol usuari i sobre les bases de dades.\nL’esquema que resumeix el comportament en aquest sentit és el següent:\n\n\n\nJerarquia de privilegis en BaseX\n\n\nObservi que els privilegis poden aplicar-se a dos nivells:\n\nGlobalment: Afectaran a totes les bases de dades i sobre la gestió mateixa del servidor.\nLocalment: Afectaran només a una base de dades específica. Si existeixen privilegis locals, aquests sobreescriuen els globals, de manera que els locals prevalen sobre els globals.\n\nA més, dos dels 5 privilegis no poden ser aplicats localment, perquè fan referència a la gestió del servidor.\nEl significat dels privilegis és força evident:\n\nNONE: Cap privilegi\nREAD: Es permet accedir a les dades, però sense modificar-les\nWRITE: Es concedeix la possibilitat de modificar les dades existents\nCREATE: S’atorga la possibilitat exclusiva de crear objectes nous\nADMIN: Es disposa de tots els privilegis, podent qualsevol ordre\n\nFinalment, tingui present que un privilegi de nivell superior engloba tots els de nivell inferior. Així doncs, si s’atorga el dret de modificació de dades WRITE, també s’està atorgant implícitament en de lectura READ.\nPer a manipular els privilegis només existeixen dues ordres relacionades:\n\n\n\n\n\n\n\nOrdre\nDescripció\n\n\n\n\nGRANT [NONE|READ|WRITE|CREATE|ADMIN] (ON [database]) TO [user]\nAtorga drets a l’usuari\n\n\nSHOW USERS (ON [database])\nMostra drets dels usuaris\n\n\n\nPosem ara uns quants exemples de com manipular privilegis:\n$ rlwrap basexclient\nUsername: admin\nPassword: admin\nBaseX 7.0.2 [Client]\nTry \"help\" to get more information.\n\n&gt; GRANT ADMIN TO admin2\nADMIN granted to 'admin2'.\n&gt; GRANT READ ON prova TO alu*\nREAD granted to 'alu01' on 'prova'.\nREAD granted to 'alu02' on 'prova'.\nREAD granted to 'alu03' on 'prova'.\nREAD granted to 'alu04' on 'prova'.\nREAD granted to 'alu05' on 'prova'.\nCom veu, assignar un dret global només implica dir el privilegi i l’usuari que el rebrà. Per assignar un dret concret sobre una base de dades específica, hem de fer servir la clàusula ON per indicar el nom de la base de dades. A més, pot veure com s’han assignat privilegis en bloc a diversos usuaris, simplement utilitzant el símbol comodí “*”.\nEls privilegis poden ser modificats en qualsevol moment. Vegi la següent seqüència d’ordres:\n&gt; GRANT CREATE ON prova TO usuari\nCREATE permission is unknown.\n&gt; GRANT CREATE TO usuari\nCREATE granted to 'usuari'.\n&gt; GRANT READ TO usuari\nREAD granted to 'usuari'.\n&gt; GRANT WRITE ON prova TO usuari\nWRITE granted to 'usuari' on 'prova'.\n&gt; GRANT NONE ON mondial TO usuari\nNONE granted to 'usuari' on 'mondial'.\nCom veu, el privilegi CREATE és global i genera un error. Si donem un dret més gran i volem reduir-lo, simplement hem de substituir tornant a definir el nivell de dret per a aquell usuari.\nFinalment, en l’exemple mostrat també s’ha indicat com podem tenir drets globals i locals diferents. En aquest cas, l’usuari “usuari” tindrà dret de lectura sobre tota base de dades (si no s’indica una altra cosa a nivell local) i específicament fixem un nivell de dret més elevat en una base de dades i un de menor en una altra. D’aquesta manera, podem fixar un dret per defecte i perfilar un de diferent per a cada base de dades concreta.\nPer acabar, podem visualitzar els drets atorgats a nivell global i/o local amb l’ordre SHOW USERS. Seguint amb el nostre exemple:\n&gt; SHOW users\nUsername  Read  Write  Create  Admin  \n------------------------------------\nadmin     X     X      X       X      \nadmin2    X     X      X       X      \nalu01                                 \nalu02                                 \nalu03                                 \nalu04                                 \nalu05                                 \nusuari    X                           \n\n8 Users.\n&gt; SHOW USERS ON prova\nUsername  Read  Write  \n---------------------\nalu01     X            \nalu02     X            \nalu03     X            \nalu04     X            \nalu05     X            \nusuari    X     X      \n\n6 Users.\n\n\n2.4. Ordres relacionades amb les còpies de seguretat\nEls backups s’emmagatzemen com a arxius de tipus ZIP al directori de dades de BaseX, que en Linux resideix al directori de l’usuari. Per exemple, /home/joan/BaseXData.\nEls arxius de backup generats per BaseX inclouen tots els arxius interns de la base de dades tal i com estan indexats i transformats internament per la base de dades.\nLes ordres relacionades amb la creació i manteniment de còpies de seguretat per a bases de dades BaseX són les següents:\n\n\n\n\n\n\n\nOrdre\nDescripció\n\n\n\n\nCOPY [name] [newname]\nCopia tota una base de dades\n\n\nCREATE BACKUP [...]\nCrea un còpia de seguretat d’una base de dades\n\n\nDROP BACKUP [...]\nElimina una còpia de seguretat\n\n\nEXPORT [path]\nExporta una base de dades a un arxiu XML\n\n\nINFO STORAGE\nMostra informació sobre l’emmagatzematge\n\n\nRESTORE [name-(date)]\nRestaura una base de dades\n\n\nSHOW BACKUPS\nMostra informació sobre les còpies de seguretat existents\n\n\n\nExemples d’ús de la funcionalitat de les còpies de seguretat:\n&gt; CREATE BACKUP mondial\nBackup for 'mondial' created in 584.35 ms.\n&gt; SHOW BACKUPS\nName                             Size    \n---------------------------------------\nmondial-2013-03-12-15-51-03.zip  913102  \n\n1 Backups.\n&gt; CREATE BACKUP mondial\nBackup for 'mondial' created in 323.53 ms.\n&gt; SHOW BACKUPS\nName                             Size    \n---------------------------------------\nmondial-2013-03-12-15-51-03.zip  913102  \nmondial-2013-03-12-20-50-43.zip  913102  \n\n2 Backups.\n&gt; RESTORE mondial\n'mondial-2013-03-12-20-50-43.zip' restored in 310.44 ms.\n&gt; RESTORE mondial-2013-03-12-15-51-03\n'mondial-2013-03-12-15-51-03.zip' restored in 274.67 ms.\nObservi que és possible restaurar un backup d’una data/hora específica, i no només la darrera còpia de seguretat.\n\n\n2.5. Ordres relacionats amb els índexs\nEls índexs permeten l’execució més ràpida de consultes d’extracció d’informació.\nRelacionat amb els índexs, només existeixen 3 funcions bàsiques:\n\n\n\nOrdre\nDescripció\n\n\n\n\nCREATE INDEX [...]\nCrea un índex nou\n\n\nDROP INDEX [...]\nElimina un índex\n\n\nINFO INDEX\nMostra informació sobre els índexs existents\n\n\n\nEn BaseX existeixen només 4 tipus d’índexs: TEXT, FULLTEXT, ATTRIBUTES, i PATH. Cadascun d’ells està especialitzat en optimitzar un aspecte diferent de les recerques i filtrat de les dades.\nEn concret, l’ordre de crear índexs no permet crear índexs sobre nodes, atributs o texts específics; sinó d’una manera genèrica per als quatre tipus esmentats.\nL’ordre de crear o eliminar índexs accepten un únic argument que coincideix amb els 4 noms indicats al paràgraf anterior:\nCREATE INDEX [TEXT|FULLTEXT|ATTRIBUTE|PATH]\nDROP INDEX [TEXT|FULLTEXT|ATTRIBUTE|PATH]\nEls índexs faran que les consultes de selecció de dades siguin molt més eficients, reduint el temps total d’obtenció dels resultats. La diferència pot arribar, en alguns casos, a nivells de reducció de temps d’execució de consultes XQuery de fins el 1/10.\n\n\n2.6. Ordres relacionats amb les consultes de dades amb XQuery\nQuant a l’execució de consultes XQuery, BaseX ens ofereix les següents ordres:\n\n\n\n\n\n\n\nOrdre\nDescripció\n\n\n\n\nCS [query]\nExecuta una consulta XQuery i fixa el resultat com a context actual\n\n\nRUN [path]\nExecuta el contingut d’un arxiu com a consulta XQuery\n\n\nXQUERY [query]\nExecuta una consulta XQuery\n\n\n\nPodem executar una consulta XQuery directament amb l’ordre XQUERY consulta, però també podem tenir-la desada a disc i indicar la ruta amb l’ordre RUN arxiu.\nAl marge d’això, sempre podem canviar de “node actiu” (context) amb l’ordre CS acompanyada d’una consulta XQuery que retorni un node del document original. Així doncs, les consultes posteriors prendran aquell context com a punt de partida (ubicació actual) i podrem utilitzar camins relatius dins del document amb consultes XQuery.\n&gt; CS //mondial/country[name='Belgium']\n&gt; XQUERY count(descendant::city)\n10\nQuery executed in 8.26 ms.\n&gt; XQUERY province/city[name='Brussels']/population/text()\n951580\n&gt; CS /\nCom veu, per retornar al nivell superior de l’arbre XML, només cal canviar el context a /.",
    "crumbs": [
      "Inici",
      "9 XND: BaseX+Java"
    ]
  },
  {
    "objectID": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html#connexió-per-a-consultes-xquery-amb-java",
    "href": "posts/2013-07-03-BD09-xnd-basex-i-java/index.html#connexió-per-a-consultes-xquery-amb-java",
    "title": "XND, BaseX i Java",
    "section": "3. Connexió per a consultes XQuery amb Java",
    "text": "3. Connexió per a consultes XQuery amb Java\nBaseX ens ofereix la possibilitat de connectar i utilitzar la seva infraestructura des dels nostres programes Java, i ho fa de diverses maneres que passarem a revisar tot seguit.\n\n3.1. Connexió local directa\nBaseX ens permet connectar des de Java directament (sense sistema de seguretat, localment).\nPer fer-ho només cal utilitzar les classes Context i XQuery que ofereixen a la seva API:\nPrograma de prova per al API de BaseX\n\n\nTest01.java\n\nimport org.basex.core.Context;\nimport org.basex.core.cmd.XQuery;\n\npublic class Test01 {\n  static Context context = new Context();\n\n  public static void main(String[] args) {\n    try {\n      long t1 = System.currentTimeMillis();\n      String query = \n        \"doc('mondial.xml')//mondial/country[name='Spain']\" +\n                    \"/province[name='Catalonia']/city/name\";\n      String result = new XQuery(query).execute(context);\n      long t2 = System.currentTimeMillis();\n      System.out.println(result);\n      System.out.println();\n      System.out.println(\"Executat en \" + (t2-t1) + \"ms\");\n    }\n    catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n\nCom veu, el codi és molt senzill però només permet l’execució de sentències XQuery.\nEl resultat de la seva execució es mostra tot seguit:\n$ javac -cp .:/usr/share/java/basex.jar Test01.java\n$ java -cp .:/usr/share/java/basex.jar Test01\n&lt;name&gt;Barcelona&lt;/name&gt;\n&lt;name&gt;Lleida&lt;/name&gt;\n&lt;name&gt;Tarragona&lt;/name&gt;\n&lt;name&gt;Hospitalet de Llobregat&lt;/name&gt;\n&lt;name&gt;Badalona&lt;/name&gt;\n&lt;name&gt;Sabadell&lt;/name&gt;\n&lt;name&gt;Terrassa&lt;/name&gt;\n&lt;name&gt;Santa Coloma de Gramanet&lt;/name&gt;\n&lt;name&gt;Mataro&lt;/name&gt;\n\nExecutat en 2455ms\n\n\n3.2. Connexió remota a través de classes client\nLa diferència és que ara utilitzarem un classe client anomenada ClientSession. Aquesta classe afegeix al mètode anterior el fet de poder connectar a un equip remot indicant usuari i contrasenya.\nPrograma de prova per al API de BaseX\n\n\nTest02.java\n\nimport org.basex.server.ClientSession;\nimport org.basex.server.ClientQuery;\n\npublic class Test02 {\n\n  public static void main(String[] args) {\n    try {\n      long t1 = System.currentTimeMillis();\n      ClientSession sessio = \n              new ClientSession(\"localhost\", 1984, \"admin\", \"admin\");\n      String query = \n        \"doc('mondial.xml')//mondial/country[name='Spain']\" +\n                    \"/province[name='Catalonia']/city/name\";\n      ClientQuery clientQuery = sessio.query(query);\n      String result = clientQuery.execute();\n      long t2 = System.currentTimeMillis();\n      System.out.println(result);\n      System.out.println();\n      System.out.println(\"Executat en \" + (t2-t1) + \"ms\");\n    }\n    catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n\nObservi que aquesta classe permet la interacció directa amb el servidor BaseX, però cal indicar el context arrel amb l’especificació del document XML que agafem de base per a la consulta.\n\n\n3.3. Mètode a través de classe wrapper\nExisteix la possibilitat de construir tota una classe que interaccioni amb la base de dades mitjançant sockets, i així implementar la connexió a baix nivell.\nDe fet, els mateixos creadors de BaseX ofereixen entre els exemples disponibles per a descarregar una classe anomenada BaseXClient que cobreix aquesta funcionalitat. Aquesta classe implementa la mateixa funcionalitat que el programa basexclient amb què ja havíem treballat.\nEl codi font de dita classe no es mostra aquí per dos motius: perquè és extens (gairebé 500 línies, moltes d’elles comentaris), i perquè és codi fet per l’equip de BaseX i està disponible a la seva web per a descarregar i també s’adjunta amb els arxius del curs.\nTornant a la funcionalitat que s’aconsegueix, les ordres i sintaxi de les mateixes coincidiran quan s’utilitza des de dita classe en Java.\nUn petit exemple d’això és el següent programa, on s’invoca una consulta XQuery sobre la base de dades Mondial, tenint en compte que el servidor existeix, està operatiu, i la base de dades està també creada i operativa. A més, l’usuari amb què fem la connexió serà el compte de l’administrador:\nPrograma de prova per al API de BaseX\n\n\nTest03.java\n\npublic class Test03 {\n\n  public static void main(String[] args) {\n    try {\n      long t1 = System.currentTimeMillis();\n      BaseXClient sessio = \n          new BaseXClient(\"localhost\", 1984, \"admin\", \"admin\");\n      String query = \n        \"XQUERY doc('mondial.xml')//mondial/country[name='Spain']\" +\n                           \"/province[name='Catalonia']/city/name\";\n      String result = sessio.execute(query);\n      long t2 = System.currentTimeMillis();\n      System.out.println(result);\n      System.out.println();\n      System.out.println(\"Executat en \" + (t2-t1) + \"ms\");\n    }\n    catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n\nPot veure com el codi ofereix la possibilitat ara d’escriure una ordre qualsevol. En aquest cas s’invoca l’ordre XQUERY per sol·licitar una consulta d’aquest tipus, però podria efectuar-se qualsevol altre tipus de tasca.\nCom a mostra d’això, vegi el següent cas on s’ha afegit l’ordre per obrir una base de dades específica, establint un context i realitzat una consulta XQuery:\nPrograma de prova per al API de BaseX\n\n\nTest04.java\n\npublic class Test04 {\n\n  public static void main(String[] args) {\n    try {\n      long t1 = System.currentTimeMillis();\n      BaseXClient sessio = \n          new BaseXClient(\"localhost\", 1984, \"admin\", \"admin\");\n      sessio.execute(\"OPEN mondial\");\n      sessio.execute(\"CS //mondial/country[name='Spain']\");\n      String query = \"XQUERY province[name='Catalonia']/city/name\";\n      String result = sessio.execute(query);\n      long t2 = System.currentTimeMillis();\n      System.out.println(result);\n      System.out.println();\n      System.out.println(\"Executat en \" + (t2-t1) + \"ms\");\n      System.exit(0);\n    }\n    catch (Exception e) {\n      System.err.println(\"ERROR: \" + e.getMessage());\n      System.exit(-1);\n    }\n  }\n}\n\nObservi com utilitzem la variable de sessió obtinguda per executar ordres BaseX segons convingui. En aquest sentit, vegi que si una instrucció fallés, es llançaria una excepció de tipus java.io.IOException.",
    "crumbs": [
      "Inici",
      "9 XND: BaseX+Java"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD03-ordbms-amb-oracle/index.html",
    "href": "posts/2013-06-29-BD03-ordbms-amb-oracle/index.html",
    "title": "ORDBMS amb Oracle",
    "section": "",
    "text": "Tota la informació està disponible al web de Oracle:\n\nIntroduction to Oracle Objects\nObject Support in Oracle Programming Environments",
    "crumbs": [
      "Inici",
      "3 Oracle ORDBMS"
    ]
  },
  {
    "objectID": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html",
    "href": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html",
    "title": "Liquid-Lipsum Jekyll Plugin",
    "section": "",
    "text": "I’ve just finished my first Jekyll plugin: the jekyll-liquid-lipsum-plugin. This Jekyll plugin inserts random text inside your posts, in order to test how the a long text will appear. It’s specially useful playing with the CSS of your site."
  },
  {
    "objectID": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#the-plugin",
    "href": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#the-plugin",
    "title": "Liquid-Lipsum Jekyll Plugin",
    "section": "The plugin",
    "text": "The plugin\nYou can access it’s source code, clone it and/or use it from Gitlab: https://gitlab.com/felix.galindo/jekyll-liquid-lipsum-plugin\nThis plugin allows you to insert random text in your posts, just to test how will appear some new environment or a new CSS class."
  },
  {
    "objectID": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#installation",
    "href": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#installation",
    "title": "Liquid-Lipsum Jekyll Plugin",
    "section": "Installation",
    "text": "Installation\nJust copy the liquid_lipsum.rb file to the _plugins folder."
  },
  {
    "objectID": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#requirements",
    "href": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#requirements",
    "title": "Liquid-Lipsum Jekyll Plugin",
    "section": "Requirements",
    "text": "Requirements\nNone. :)"
  },
  {
    "objectID": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#configuration",
    "href": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#configuration",
    "title": "Liquid-Lipsum Jekyll Plugin",
    "section": "Configuration",
    "text": "Configuration\nNone. :)"
  },
  {
    "objectID": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#usage",
    "href": "posts/2013-11-09-liquid-lipsum-jekyll-plugin/index.html#usage",
    "title": "Liquid-Lipsum Jekyll Plugin",
    "section": "Usage",
    "text": "Usage\nIt’s usage is simple. For example, you insert this line in one of your posts:\n{% lipsum %}\nAnd you’ll get something like this:\n\nAenean id lacinia neque nec bibendum odio risus a arcu imperdiet metus id velit augue id magna iaculis quis, pretium quam iaculis quis, sit amet nibh ullamcorper nec, pretium quam nonummy ac, erat libero tristique tellus, turpis at pulvinar vulputate, sed nisl molestie nec bibendum odio risus erat libero tristique tellus, a arcu imperdiet pretium quam turpis at pulvinar vulputate, sit amet nibh rutrum non, pretium quam augue id magna ullamcorper nec, porttitor ut, porttitor ut, nec bibendum odio risus sit amet nibh sit amet ante.\n\nAs you can see, a full paragraph of random text will substitute the original liquid tag.\nEach paragraph will have a beginning, a middle part and an ending. The size of the paragraph corresponds to the number of middle parts. A number of 3 will have 3 middle parts.\nThe following paragraph has a size of 1: Nam quis nulla ullamcorper nec, sit amet ante. The begining is “Nam quis nulla”, the middle part is “ullamcorper nec,” and the ending is “sit amet ante”.\nThe beginings, middle parts and endings are taken randomly from 3 different pools of text.\nThe tag allows up to three numbers as parameters:\n\nThe first number represents the number of paragraphs to be generated,\nThe second number is the minimum size of the paragraph (number of middle parts).\nThe third number is the maximum size of the paragraph (number of middle parts).\n\nCombining this, you can have the following situations:\nUse cases of the tag:\n\n\n\n\n\n\n\nUsage\nResult\n\n\n\n\n{% lipsum %}\n1 paragraph. Random length between 10 and 30\n\n\n{% lipsum n %}\nn paragraphs. Random length between 10 and 30\n\n\n{% lipsum n l %}\nn paragraphs. Exactly a length of l\n\n\n{% lipsum n l1 l2 %}\nn paragraphs. Random length between l1 and l2\n\n\n\nYou can improve or modify the behaviour of this liquid tag by simply editing its source code. There you can change the sentence parts to your wishes by simply editing the three arrays of strings from which the generator takes the text parts."
  },
  {
    "objectID": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html",
    "href": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html",
    "title": "XML i Java amb StaX i JAXB",
    "section": "",
    "text": "XML són les sigles de eXtensible Markup Language, i va ser definit el 1998 pel World Wide Web Consortium (W3C).\nEls documents XML estan formats per una col·lecció d’elements. Cadascun d’ells està delimitat entre marques d’inici i de final (aquestes marques habitualment s’anomenen tags).\nTot document XML ha de presentar un únic element arrel, que encerclarà tots els altres elements. Aquest element arrel és únic (un i només un) i serà l’arrel de l’arbre d’elements que conformen el document.\nS’ha de tenir en compte que l’especificació dels arxius XML diferencia entre majúscules i minúscules i cal tenir això present en la seva definició i manipulació.\nCaracterístiques d’un arxiu XML correctament formatat:\n\nSempre comença per un pròleg.\nCada marca d’apertura té la seva corresponent de tancament.\nTotes les marques estan completament niades (estructurades en arbre).\n\nCaracterístiques d’un arxiu XML vàlid:\n\nHa de ser correctament formatat (criteris anteriors).\nHa de contenir un enllaç a un esquema XML i ha de ser vàlid respecte d’aquell esquema.\n\n\n\n\nEl següent és un arxiu XML correctament formatat i vàlid:\nArxiu biblio.xml\n\n\nbiblio.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE biblioteca SYSTEM \"biblio.dtd\"&gt;\n&lt;!-- Un exemple de base de dades bibliogràfica --&gt;\n&lt;biblioteca&gt;\n  &lt;llibre isbn='978-0156837507'&gt;\n    &lt;idioma&gt;en&lt;/idioma&gt;\n    &lt;titol&gt;Solaris&lt;/titol&gt;\n    &lt;autor&gt;Stanislaw Lem&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn='978-2070575923'&gt;\n    &lt;idioma&gt;fr&lt;/idioma&gt;\n    &lt;titol&gt;Le Petit Prince&lt;/titol&gt;\n    &lt;autor&gt;Antoine de Saint-Exupéry&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn='978-8474103656'&gt;\n    &lt;idioma&gt;ca&lt;/idioma&gt;\n    &lt;titol&gt;&lt;![CDATA[La fi de l'eternitat]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Isaac Asimov&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn='978-0441010622'&gt;\n    &lt;idioma&gt;en&lt;/idioma&gt;\n    &lt;titol&gt;Dune&lt;/titol&gt;\n    &lt;autor&gt;Frank Herbert&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;!-- més llibres ... --&gt;\n&lt;/biblioteca&gt;\n\n\n\n\nObservant l’exemple mostrat, destaquem les següents característiques en el seu format:\n\nEls arxius XML, com es veu, sempre comencen per un pròleg que descriu l’arxiu XML mateix. Aquest pròleg pot ser mínim, com:\n&lt;?xml version=\"1.0\"?&gt;\nO pot contenir altre informació, com la codificació dels caràcters i altres propietats:\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?&gt;\nTambé s’ha de tenir en compte que un tag que no conté contingut al seu interior es coneix com a tag buit. Per exemple: “&lt;logo/&gt;”.\nEls comentaris en XML es defineixen així: &lt;!-- comentari --&gt;.\nSi hem d’incloure algun caràcter que pugui ser interpretat per la mateixa sintaxi de XML, haurem d’escapar-lo per prevenir la confusió amb el significat estàndard. Els caràcters que presenten escapament són els següents:\n\n\n\n\nCaràcter\nCodi escapat\n\n\n\n\n& (ampersand)\n&amp;\n\n\n&lt; (menor que)\n&lt;\n\n\n&gt; (major que)\n&gt;\n\n\n' (cometa simple)\n&apos;\n\n\n\" (cometa doble)\n&quot;\n\n\n\n\n\n\nEn un arxiu o document XML, una secció CDATA és una secció de contingut d’un element que és marcat com a dades exclusivament, de manera que no s’interpreti el seu contingut com a ordres o marques de sintaxi.\nPer tant, una secció CDATA és simplement una alternativa de sintaxi per expressar dades textuals, on cap caràcter especial hagi hagut de ser escapat (sense necessitat de &lt; o &, per exemple).\nLa secció marcada CDATA ha d’estar encerclada de la següent manera:\n&lt;![CDATA[ ... text ... ]]&gt;\nTot el text inclòs en la secció CDATA serà interpretat com a caràcters literal, sense marques o referència a entitats.\nAixí doncs, si en un document XML haguéssim d’enregistrar una condició com (edat&lt;40) && (tipus&gt;3), ho podríem fer de dues maneres:\n&lt;condicio&gt; (edat&lt;40) &amp;&amp; (tipus&gt;3) &lt;/condicio&gt;\n&lt;condicio&gt;&lt;![CDATA[ (edat&lt;40) && (tipus&gt;3) ]]&gt;&lt;/condicio&gt;\nCom es veu, la segona permet una lectura immediata, però ha d’estar encerclada entre les marques que defineixen la secció CDATA.\n\n\n\nEl mecanisme més senzill per proporcionar una sintaxi per a l’estructura d’un document XML determinat és la definició d’un DTD (Document Type Definition). N’hi ha altres tècniques, però aquesta és la més senzilla i còmoda, a més de formar part de l’estàndard original XML.\nEn aquest sentit, un esquema XML especifica formalment l’estructura del document XML, permetent:\n\nValidació: Assegurem que conté les dades correctes en els llocs correctes.\nInteroperativitat: Com que disposar de la sintaxi de l’estructura no genera dubtes, diferents equips de persones poden treballar en el document sabent de quina manera quedarà estructurada la informació.\nGeneració de codi: Es poden utilitzar els esquemes XML per generar codi que permeti als desenvolupadors llegir i escriure documents XML seguint l’estructuració descrita. A aquesta tècnica se la coneix com Binding i serà estudiada en el curs. Existeix Binding XML de dades per a C#, C++, Java, Visual Basic, VB.Net, entre altres.\nVisualitzacions: És possible mostrar de manera adient l’estructura d’un arxiu XML si coneixem la seva sintaxi estructural. Així podem generar vistes sobre les dades del document o automatitzar processos de visualització de forma senzilla.\nDocumentació: Un esquema XML pot contenir documentació, que serà processada a altres formats segons convingui.\n\nUn exemple d’esquema XML en format DTD podria ser el següent:\n\n\nbiblio.dtd\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!-- Aquesta és la DTD de la biblioteca --&gt;\n\n&lt;!ELEMENT biblioteca (llibre)*&gt;\n&lt;!ELEMENT llibre (idioma, titol, autor)&gt;\n&lt;!ATTLIST llibre isbn CDATA #REQUIRED&gt;\n&lt;!ELEMENT idioma (#PCDATA)&gt;\n&lt;!ELEMENT titol (#PCDATA)&gt;\n&lt;!ELEMENT autor (#PCDATA)&gt;\n\nObservi com s’indica que una biblioteca està formada per un o més llibres, que els llibres han de presentar tres elements al seu interior (idioma, títol i autor) i un atribut (el ISBN).\nObservi també com s’ha especificat el tipus de dades dels diferents elements: el ISBN és CDATA (text directe) mentre que els elements idioma, títol i autor són text interpretat (que pot escapar-se o encerclar-se amb una secció CDATA).\n\n\n\nEls avantatges més importants de fer servir arxius XML sobre altres tipus de format són:\n\nEl contingut dels arxius XML és text pla.\nRepresenta dades sense definir com han de ser mostrades.\nPot ser transformat en altres formats aplicant XSL.\nPot ser fàcilment processat mitjançant parsers estàndard.\nPresenta una estructura jeràrquica.\n\nNomés destaca un inconvenient, i és que en alguns tipus de documents i dades genera un gran volum de marques per descriure correctament el contingut de dades del mateix. Un exemple d’això és MathML (que molt poca gent fa servir en productes comercials).\nObservi el següent exemple de MathML:\n&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"&gt;\n  &lt;mrow&gt;\n    &lt;mi&gt;x&lt;/mi&gt;\n    &lt;mo&gt;=&lt;/mo&gt;\n    &lt;mfrac&gt;\n      &lt;mrow&gt;\n        &lt;mo&gt;&#x2212;&lt;/mo&gt;\n        &lt;mi&gt;b&lt;/mi&gt;\n        &lt;mo&gt;&#xB1;&lt;/mo&gt;\n        &lt;msqrt&gt;\n          &lt;mrow&gt;\n            &lt;msup&gt;\n              &lt;mi&gt;b&lt;/mi&gt;\n              &lt;mn&gt;2&lt;/mn&gt;\n            &lt;/msup&gt;\n            &lt;mo&gt;&#x2212;&lt;/mo&gt;\n            &lt;mn&gt;4&lt;/mn&gt;\n            &lt;mi&gt;a&lt;/mi&gt;\n            &lt;mi&gt;c&lt;/mi&gt;\n          &lt;/mrow&gt;\n        &lt;/msqrt&gt;\n      &lt;/mrow&gt;\n      &lt;mrow&gt;\n        &lt;mn&gt;2&lt;/mn&gt;\n        &lt;mi&gt;a&lt;/mi&gt;\n      &lt;/mrow&gt;\n    &lt;/mfrac&gt;\n  &lt;/mrow&gt;\n&lt;/math&gt;\nEl resultat d’aquest XML, aplicant-li un renderitzador adequat (per exemple, el navegador Safari n’incorpora un per defecte), serà visualitzat com a:\n\n\n\n\nFormula MathML renderitzada\n\n\n\nAquesta mateixa fórmula, codificada en LaTeX, simplement és:\nx=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\nResultant en:\n\\[ x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a} \\]\nPodem dir que XML és útil sempre i quan és evident aplicar-lo. Si quan l’apliquem, l’estructura és complexa i difícil de seguir i llegir, aleshores és millor alguna altra alternativa, excepte el cas en què volem un format uniforme que sempre tingui el mateix aspecte i estructura.\nNo és la finalitat d’aquest curs aprendre les interioritats i detalls menors en l’estructura de XML, però sí en farem ús i per tant hem d’estar familiaritzats amb els seus trets bàsics. D’aquí que s’hagi presentat una introducció al tema i no una anàlisi en profunditat.",
    "crumbs": [
      "Inici",
      "4 StaX i JAXB"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#arxius-xml",
    "href": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#arxius-xml",
    "title": "XML i Java amb StaX i JAXB",
    "section": "",
    "text": "XML són les sigles de eXtensible Markup Language, i va ser definit el 1998 pel World Wide Web Consortium (W3C).\nEls documents XML estan formats per una col·lecció d’elements. Cadascun d’ells està delimitat entre marques d’inici i de final (aquestes marques habitualment s’anomenen tags).\nTot document XML ha de presentar un únic element arrel, que encerclarà tots els altres elements. Aquest element arrel és únic (un i només un) i serà l’arrel de l’arbre d’elements que conformen el document.\nS’ha de tenir en compte que l’especificació dels arxius XML diferencia entre majúscules i minúscules i cal tenir això present en la seva definició i manipulació.\nCaracterístiques d’un arxiu XML correctament formatat:\n\nSempre comença per un pròleg.\nCada marca d’apertura té la seva corresponent de tancament.\nTotes les marques estan completament niades (estructurades en arbre).\n\nCaracterístiques d’un arxiu XML vàlid:\n\nHa de ser correctament formatat (criteris anteriors).\nHa de contenir un enllaç a un esquema XML i ha de ser vàlid respecte d’aquell esquema.\n\n\n\n\nEl següent és un arxiu XML correctament formatat i vàlid:\nArxiu biblio.xml\n\n\nbiblio.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE biblioteca SYSTEM \"biblio.dtd\"&gt;\n&lt;!-- Un exemple de base de dades bibliogràfica --&gt;\n&lt;biblioteca&gt;\n  &lt;llibre isbn='978-0156837507'&gt;\n    &lt;idioma&gt;en&lt;/idioma&gt;\n    &lt;titol&gt;Solaris&lt;/titol&gt;\n    &lt;autor&gt;Stanislaw Lem&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn='978-2070575923'&gt;\n    &lt;idioma&gt;fr&lt;/idioma&gt;\n    &lt;titol&gt;Le Petit Prince&lt;/titol&gt;\n    &lt;autor&gt;Antoine de Saint-Exupéry&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn='978-8474103656'&gt;\n    &lt;idioma&gt;ca&lt;/idioma&gt;\n    &lt;titol&gt;&lt;![CDATA[La fi de l'eternitat]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Isaac Asimov&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn='978-0441010622'&gt;\n    &lt;idioma&gt;en&lt;/idioma&gt;\n    &lt;titol&gt;Dune&lt;/titol&gt;\n    &lt;autor&gt;Frank Herbert&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;!-- més llibres ... --&gt;\n&lt;/biblioteca&gt;\n\n\n\n\nObservant l’exemple mostrat, destaquem les següents característiques en el seu format:\n\nEls arxius XML, com es veu, sempre comencen per un pròleg que descriu l’arxiu XML mateix. Aquest pròleg pot ser mínim, com:\n&lt;?xml version=\"1.0\"?&gt;\nO pot contenir altre informació, com la codificació dels caràcters i altres propietats:\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?&gt;\nTambé s’ha de tenir en compte que un tag que no conté contingut al seu interior es coneix com a tag buit. Per exemple: “&lt;logo/&gt;”.\nEls comentaris en XML es defineixen així: &lt;!-- comentari --&gt;.\nSi hem d’incloure algun caràcter que pugui ser interpretat per la mateixa sintaxi de XML, haurem d’escapar-lo per prevenir la confusió amb el significat estàndard. Els caràcters que presenten escapament són els següents:\n\n\n\n\nCaràcter\nCodi escapat\n\n\n\n\n& (ampersand)\n&amp;\n\n\n&lt; (menor que)\n&lt;\n\n\n&gt; (major que)\n&gt;\n\n\n' (cometa simple)\n&apos;\n\n\n\" (cometa doble)\n&quot;\n\n\n\n\n\n\nEn un arxiu o document XML, una secció CDATA és una secció de contingut d’un element que és marcat com a dades exclusivament, de manera que no s’interpreti el seu contingut com a ordres o marques de sintaxi.\nPer tant, una secció CDATA és simplement una alternativa de sintaxi per expressar dades textuals, on cap caràcter especial hagi hagut de ser escapat (sense necessitat de &lt; o &, per exemple).\nLa secció marcada CDATA ha d’estar encerclada de la següent manera:\n&lt;![CDATA[ ... text ... ]]&gt;\nTot el text inclòs en la secció CDATA serà interpretat com a caràcters literal, sense marques o referència a entitats.\nAixí doncs, si en un document XML haguéssim d’enregistrar una condició com (edat&lt;40) && (tipus&gt;3), ho podríem fer de dues maneres:\n&lt;condicio&gt; (edat&lt;40) &amp;&amp; (tipus&gt;3) &lt;/condicio&gt;\n&lt;condicio&gt;&lt;![CDATA[ (edat&lt;40) && (tipus&gt;3) ]]&gt;&lt;/condicio&gt;\nCom es veu, la segona permet una lectura immediata, però ha d’estar encerclada entre les marques que defineixen la secció CDATA.\n\n\n\nEl mecanisme més senzill per proporcionar una sintaxi per a l’estructura d’un document XML determinat és la definició d’un DTD (Document Type Definition). N’hi ha altres tècniques, però aquesta és la més senzilla i còmoda, a més de formar part de l’estàndard original XML.\nEn aquest sentit, un esquema XML especifica formalment l’estructura del document XML, permetent:\n\nValidació: Assegurem que conté les dades correctes en els llocs correctes.\nInteroperativitat: Com que disposar de la sintaxi de l’estructura no genera dubtes, diferents equips de persones poden treballar en el document sabent de quina manera quedarà estructurada la informació.\nGeneració de codi: Es poden utilitzar els esquemes XML per generar codi que permeti als desenvolupadors llegir i escriure documents XML seguint l’estructuració descrita. A aquesta tècnica se la coneix com Binding i serà estudiada en el curs. Existeix Binding XML de dades per a C#, C++, Java, Visual Basic, VB.Net, entre altres.\nVisualitzacions: És possible mostrar de manera adient l’estructura d’un arxiu XML si coneixem la seva sintaxi estructural. Així podem generar vistes sobre les dades del document o automatitzar processos de visualització de forma senzilla.\nDocumentació: Un esquema XML pot contenir documentació, que serà processada a altres formats segons convingui.\n\nUn exemple d’esquema XML en format DTD podria ser el següent:\n\n\nbiblio.dtd\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!-- Aquesta és la DTD de la biblioteca --&gt;\n\n&lt;!ELEMENT biblioteca (llibre)*&gt;\n&lt;!ELEMENT llibre (idioma, titol, autor)&gt;\n&lt;!ATTLIST llibre isbn CDATA #REQUIRED&gt;\n&lt;!ELEMENT idioma (#PCDATA)&gt;\n&lt;!ELEMENT titol (#PCDATA)&gt;\n&lt;!ELEMENT autor (#PCDATA)&gt;\n\nObservi com s’indica que una biblioteca està formada per un o més llibres, que els llibres han de presentar tres elements al seu interior (idioma, títol i autor) i un atribut (el ISBN).\nObservi també com s’ha especificat el tipus de dades dels diferents elements: el ISBN és CDATA (text directe) mentre que els elements idioma, títol i autor són text interpretat (que pot escapar-se o encerclar-se amb una secció CDATA).\n\n\n\nEls avantatges més importants de fer servir arxius XML sobre altres tipus de format són:\n\nEl contingut dels arxius XML és text pla.\nRepresenta dades sense definir com han de ser mostrades.\nPot ser transformat en altres formats aplicant XSL.\nPot ser fàcilment processat mitjançant parsers estàndard.\nPresenta una estructura jeràrquica.\n\nNomés destaca un inconvenient, i és que en alguns tipus de documents i dades genera un gran volum de marques per descriure correctament el contingut de dades del mateix. Un exemple d’això és MathML (que molt poca gent fa servir en productes comercials).\nObservi el següent exemple de MathML:\n&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"&gt;\n  &lt;mrow&gt;\n    &lt;mi&gt;x&lt;/mi&gt;\n    &lt;mo&gt;=&lt;/mo&gt;\n    &lt;mfrac&gt;\n      &lt;mrow&gt;\n        &lt;mo&gt;&#x2212;&lt;/mo&gt;\n        &lt;mi&gt;b&lt;/mi&gt;\n        &lt;mo&gt;&#xB1;&lt;/mo&gt;\n        &lt;msqrt&gt;\n          &lt;mrow&gt;\n            &lt;msup&gt;\n              &lt;mi&gt;b&lt;/mi&gt;\n              &lt;mn&gt;2&lt;/mn&gt;\n            &lt;/msup&gt;\n            &lt;mo&gt;&#x2212;&lt;/mo&gt;\n            &lt;mn&gt;4&lt;/mn&gt;\n            &lt;mi&gt;a&lt;/mi&gt;\n            &lt;mi&gt;c&lt;/mi&gt;\n          &lt;/mrow&gt;\n        &lt;/msqrt&gt;\n      &lt;/mrow&gt;\n      &lt;mrow&gt;\n        &lt;mn&gt;2&lt;/mn&gt;\n        &lt;mi&gt;a&lt;/mi&gt;\n      &lt;/mrow&gt;\n    &lt;/mfrac&gt;\n  &lt;/mrow&gt;\n&lt;/math&gt;\nEl resultat d’aquest XML, aplicant-li un renderitzador adequat (per exemple, el navegador Safari n’incorpora un per defecte), serà visualitzat com a:\n\n\n\n\nFormula MathML renderitzada\n\n\n\nAquesta mateixa fórmula, codificada en LaTeX, simplement és:\nx=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\nResultant en:\n\\[ x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a} \\]\nPodem dir que XML és útil sempre i quan és evident aplicar-lo. Si quan l’apliquem, l’estructura és complexa i difícil de seguir i llegir, aleshores és millor alguna altra alternativa, excepte el cas en què volem un format uniforme que sempre tingui el mateix aspecte i estructura.\nNo és la finalitat d’aquest curs aprendre les interioritats i detalls menors en l’estructura de XML, però sí en farem ús i per tant hem d’estar familiaritzats amb els seus trets bàsics. D’aquí que s’hagi presentat una introducció al tema i no una anàlisi en profunditat.",
    "crumbs": [
      "Inici",
      "4 StaX i JAXB"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#mètodes-daccés-a-arxius-xml",
    "href": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#mètodes-daccés-a-arxius-xml",
    "title": "XML i Java amb StaX i JAXB",
    "section": "2. Mètodes d’accés a arxius XML",
    "text": "2. Mètodes d’accés a arxius XML\nPer accedir a les dades que estan emmagatzemades en un document XML, podem triar entre dues tècniques bàsiques:\n\nEl parser o analitzador sintàctic: Aquest mecanisme consisteix en recórrer l’arxiu XML per extreure la informació seguint les característiques estructurals que presenta. Requereix codificar (d’una manera o altre) la sintaxi de l’esquema utilitzat o proporcionar l’esquema externament, de manera que el parser pugui interpretar l’estructura de manera adequada.\nEl binding o vinculació de dades: Aquest altre mecanisme permet vincular les dades dels objectes i estructures del llenguatge amb els seus corresponents elements del document XML. D’alguna manera es realitza una sincronització entre la rèplica en memòria utilitzada pel llenguatge d’alt nivell i la representació emmagatzemada en el document XML al disc dur.\n\nDe la primera tècnica, el parser, nosaltres treballarem sobre la API de Java anomenada StaX; mentre que sobre la part de binding treballarem amb el API anomenat JAXB.",
    "crumbs": [
      "Inici",
      "4 StaX i JAXB"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#una-api-java-de-parser-stax",
    "href": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#una-api-java-de-parser-stax",
    "title": "XML i Java amb StaX i JAXB",
    "section": "3. Una API Java de parser: StaX",
    "text": "3. Una API Java de parser: StaX\nLa tècnica de parser consisteix en recórrer l’arxiu XML i anar descobrint els elements i tags que s’hi troben. En funció de cada cas, el lector anirà enviant la informació trobada a la variable, estructura o classe adient.\nPer tant, el programador ha de tenir un coneixement clar de l’estructura del document XML (el seu esquema) i codificar l’anàlisi de l’esquema en el codi del programa. Per a estructures senzilles això no és gaire complicat, però per documents XML amb múltiples nivells jeràrquics, la cosa pot ser força incòmoda i feixuga.\nCom a exemple, vegem la següent situació: Disposem de l’arxiu de biblioteca anterior biblio.xml i volem escriure un lector i un escriptor d’aquest format de document.\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple número 4\n\n\nCom es veu, el programa desitjat hauria de llegir la biblioteca de l’arxiu, afegir dos llibres més i escriure la biblioteca en un nou arxiu anomenat biblio2.xml.\nTal i com s’ha codificat el programa, necessitem de dues classes noves: Biblioteca i Llibre per mantenir la informació en memòria.\nLa classe Llibre simplement és una típica classe POJO amb els mètodes setter i getter corresponents per a cada atribut del llibre. A més, una funció toString() que mostra la informació del llibre per pantalla.\nQuant a la biblioteca, la cosa ja és més complexa, perquè no només és una llista de llibres, sinó que també hi implementem la lectura i escriptura en arxius XML. Aquesta classe presenta dues parts ben diferenciades:\n\nPer una banda, tenim el fet que “una biblioteca és una col·lecció de llibres” i això ens comporta una declaració i uns mètodes relacionats.\nPer altra banda, necessitem els mètodes que llegeixen i escriure la informació en arxius XML, i són les funcions carregarXML() i desarXML(). Les dues reben el nom d’arxiu de què es vol llegir o on es vol escriure, respectivament.\n\nParlem ara dels mètodes relacionats amb XML (la part prèvia hauria de ser evident a la vista del codi).\n\n3.1. Càrrega d’arxius XML\nQuant a la càrrega des d’un arxiu XML, podrà observar en la codificació de la funció carregarXML() que requerim un objecte XMLEventReader que és el que va llegint i trobant elements dins de l’arxiu XML. Aquest objecte s’instancia a partir d’un lector d’arxiu de tipus FileInputStream.\nCada vegada que trobem un esdeveniment (amb er.hasNext()), hem de gestionar el seu significat en funció del tag o estructura que contingui:\n\nSi és un inici de tag &lt;llibre&gt;, haurem de llegir l’atribut ISBN.\nSi és un inici de tag &lt;idioma&gt;, &lt;titol&gt; o &lt;autor&gt;, simplement llegim la dada continguda com a bloc de text.\nSi és un tancament de tag &lt;llibre&gt;, haurem de desar el llibre llegit a la biblioteca (cridant afegirLlibre()).\n\n\n\n3.2. Escriptura d’arxius XML\nQuant a l’escriptura a un arxiu XML, podrà veure a la funció desarXML() que hem de realitzar el procés invers al de lectura, generant esdeveniments (elements i atributs) que vagin afegint-se a l’arxiu. És un procés semblant al d’anar escrivint text mesclat amb variables amb funcions bàsiques com println(), però amb mètodes relacionats amb XML.\nObservi com definim un XMLEventWriter que és l’encarregat de gestionar l’escriptura en arxiu amb un FileOutputStream com a destí de l’escriptura.\nObservarà com es van enviant els diferents elements (inici de document, definició del DTD, afegir un comentari, inici del tag principal &lt;biblioteca&gt;) i aleshores passem a escriure, un a un, tots els llibres de la biblioteca. Posteriorment tancarem el tag de &lt;biblioteca&gt; i el document.\nEn el cas del format de sortida, s’ha volgut modificar el format, de manera que ara l’idioma sigui un atribut del llibre i no un element diferenciat. Per tant, per a cada llibre s’escriurà el tag d’obertura juntament amb el ISBN i l’idioma, i després el títol i l’autor en tags diferenciats. A més, tots els títols han d’aparèixer escapats dins d’un tag CDATA.\nObservi també com s’han anat afegint tabuladors i finals de línia.\nL’arxiu generat ha quedat així:\n\n\nbiblio2.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE biblioteca SYSTEM \"biblio.dtd\"&gt;\n&lt;!--Un exemple de base de dades bibliogràfica--&gt;\n&lt;biblioteca&gt;\n  &lt;llibre isbn=\"978-0156837507\" idioma=\"en\"&gt;\n    &lt;titol&gt;&lt;![CDATA[Solaris]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Stanislaw Lem&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn=\"978-2070575923\" idioma=\"fr\"&gt;\n    &lt;titol&gt;&lt;![CDATA[Le Petit Prince]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Antoine de Saint-Exupéry&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn=\"978-8474103656\" idioma=\"ca\"&gt;\n    &lt;titol&gt;&lt;![CDATA[La fi de l'eternitat]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Isaac Asimov&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn=\"978-0441010622\" idioma=\"en\"&gt;\n    &lt;titol&gt;&lt;![CDATA[Dune]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Frank Herbert&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn=\"978-84-615-9841-0\" idioma=\"ca\"&gt;\n    &lt;titol&gt;&lt;![CDATA[Oracle SQL és fàcil!]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Fèlix Galindo Allué&lt;/autor&gt;\n  &lt;/llibre&gt;\n  &lt;llibre isbn=\"0-13-027363-5\" idioma=\"en\"&gt;\n    &lt;titol&gt;&lt;![CDATA[Thinking in Java]]&gt;&lt;/titol&gt;\n    &lt;autor&gt;Bruce Eckel&lt;/autor&gt;\n  &lt;/llibre&gt;\n&lt;/biblioteca&gt;\n\nCom veu, la tècnica és senzilla, però es fa llarga la codificació del programa si l’estructura jeràrquica té molts nivells intermedis. Pensi, per exemple, com s’hauria d’implementar un lector per a la fórmula MathML mostrada anteriorment!!!",
    "crumbs": [
      "Inici",
      "4 StaX i JAXB"
    ]
  },
  {
    "objectID": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#una-api-java-per-a-binding-jaxb",
    "href": "posts/2013-06-29-BD04-xml-java-stax-jaxb/index.html#una-api-java-per-a-binding-jaxb",
    "title": "XML i Java amb StaX i JAXB",
    "section": "4. Una API Java per a binding: JAXB",
    "text": "4. Una API Java per a binding: JAXB\nLa tècnica anomenada binding consisteix en vincular un objecte o un grup d’objectes amb un document XML, de manera que pugui ser importat cap a aquests objectes i després exportat de nou cap al document:\n\nQuan s’importa el document XML (unmarshalling), es crearan objectes Java associats a aquelles dades XML i amb els atributs assignats als valors que correspongui segons el contingut de l’arxiu XML.\nQuan s’exporta el document XML (marshalling), els atributs i valors dels objectes Java seran desats a l’arxiu XML resseguint l’estructura de dades present als objectes.\n\nPer a que tot això sigui possible, Java ha de conèixer els atributs i els seus noms associats al document XML. A més, els tipus de dada han de ser senzills: enters, text, llistes bàsiques, etc.\nPer poder marcar aquestes qüestions s’utilitza una tècnica addicional anomenada annotation. Amb aquesta tècnica s’inclouen directrius que ajuden a discernir característiques i condicions sobre la vinculació dades–XML.\nVegem ara com es construiria una aplicació semblant a la anteriorment mostrada per al cas StaX. Considerem el mateix programa de prova i adaptem-lo a la nova tècnica.\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple número 5\n\n\nQuant a la classe ProvaBiblioteca (el programa principal), només hi ha dos canvis importants: S’ha canviat la manera de carregar la biblioteca a un mètode estàtic i s’ha canviat el nom de l’arxiu resultant.\nPer a la declaració de la classe Llibre observarà que, com abans, aquesta classe conté la definició dels atributs i els seus corresponents mètodes setter i getter.\nA més, trobarà les següents annotations:\n\nAmb @XmlRootElement(name = \"llibre\") (línia 5) indiquem que el nom de l’element XML associat a aquesta classe és el tag &lt;llibre&gt;. Observi que la classe té la primera lletra en majúscules i Java és sensible a majúscules. Per això cal indicar la traducció.\nAmb @XmlType(propOrder = { \"idioma\", \"autor\", \"titol\" }) (línia 6) indiquem que aquesta classe té aquestes tres propietats associades amb els atributs del mateix nom. Això vol dir que haurà de cercar al document XML aquests tres elements dins del tag assignat a cada llibre.\nAmb @XmlAttribute (línia 22) indiquem que el getter indicat a la línia següent correspon a un atribut del tag &lt;llibre&gt;, a diferència dels altres tres elements.\n\nI per a la classe Biblioteca tindrem també algunes annotations:\n\nAmb @XmlRootElement(name = \"biblioteca\") (línia 8) indiquem com abans que el nom del tag associat a aquesta classe es dirà &lt;biblioteca&gt;.\nAmb @XmlElement(name = \"llibre\") (línia 14) indiquem que aquesta classe és un receptacle de tags &lt;llibre&gt;. Com abans, s’indica just abans del getter d’aquest element. Els elements descoberts seran enregistrats internament al ArrayList indicat a la línia 10.\n\nQuan a les funcions de lectura i escriptura del document XML, comentar que:\n\nS’ha fet la funció de càrrega en forma estàtica, perquè la lectura que realitza JAXB ja retorna un objecte de la classe arrel.\nSobre la forma de fer la lectura, veurà que el procés és força planer un cop es coneix. S’indica la classe arrel del document (en aquest cas la classe Biblioteca) i el nom de l’arxiu al procés de unmarshalling.\nSobre la forma de fer l’escriptura, veurà que el procés és idèntic al de lectura, canviant el mètode al de marshalling.\nA més, en l’escriptura, s’ha indicat amb la propietat adient que volem que faci un bon formatat del document (amb tabuladors i retorns de línia). Si no es posa, el document XML resultant queda tot en una sola línia seguida.\n\nEl resultat de l’execució d’aquest programa és idèntic a l’anterior. El document XML resultant quedarà així:\n\n\nbiblio3.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;\n&lt;biblioteca&gt;\n    &lt;llibre isbn=\"978-0156837507\"&gt;\n        &lt;idioma&gt;en&lt;/idioma&gt;\n        &lt;autor&gt;Stanislaw Lem&lt;/autor&gt;\n        &lt;titol&gt;Solaris&lt;/titol&gt;\n    &lt;/llibre&gt;\n    &lt;llibre isbn=\"978-2070575923\"&gt;\n        &lt;idioma&gt;fr&lt;/idioma&gt;\n        &lt;autor&gt;Antoine de Saint-Exupéry&lt;/autor&gt;\n        &lt;titol&gt;Le Petit Prince&lt;/titol&gt;\n    &lt;/llibre&gt;\n    &lt;llibre isbn=\"978-8474103656\"&gt;\n        &lt;idioma&gt;ca&lt;/idioma&gt;\n        &lt;autor&gt;Isaac Asimov&lt;/autor&gt;\n        &lt;titol&gt;La fi de l'eternitat&lt;/titol&gt;\n    &lt;/llibre&gt;\n    &lt;llibre isbn=\"978-0441010622\"&gt;\n        &lt;idioma&gt;en&lt;/idioma&gt;\n        &lt;autor&gt;Frank Herbert&lt;/autor&gt;\n        &lt;titol&gt;Dune&lt;/titol&gt;\n    &lt;/llibre&gt;\n    &lt;llibre isbn=\"978-84-615-9841-0\"&gt;\n        &lt;idioma&gt;ca&lt;/idioma&gt;\n        &lt;autor&gt;Fèlix Galindo Allué&lt;/autor&gt;\n        &lt;titol&gt;Oracle SQL és fàcil!&lt;/titol&gt;\n    &lt;/llibre&gt;\n    &lt;llibre isbn=\"0-13-027363-5\"&gt;\n        &lt;idioma&gt;en&lt;/idioma&gt;\n        &lt;autor&gt;Bruce Eckel&lt;/autor&gt;\n        &lt;titol&gt;Thinking in Java&lt;/titol&gt;\n    &lt;/llibre&gt;\n&lt;/biblioteca&gt;\n\nCom veu, inclou els 6 llibres correctament formatats seguint l’estructura dels objectes i les seves dades.\nEvidentment aquesta tècnica és aparentment més còmoda, però es complica quan volem utilitzar tipus de dades diferents dels bàsics, o quan volem realitzar estructures XML complexes. No obstant, el codi generat ha estat mínim i resulta una bona primera aproximació per a la lectura i escriptura d’arxius XML senzills.",
    "crumbs": [
      "Inici",
      "4 StaX i JAXB"
    ]
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html",
    "href": "posts/2010-11-17-format-intel-hex/index.html",
    "title": "Format Intel HEX",
    "section": "",
    "text": "Els arxius Intel HEX són en realitat arxius de text que segueixen el format anomenat “Intel HEX format”.\nCada línia d’aquests arxius conté un registre HEX. Aquests registres estan formats per nombres expressats en base hexadecimal que representen el codi de llenguatge màquina i/o dades constants.\nEls arxius Intel HEX s’utilitzen habitualment per transferir programes i dades que podran ser emmagatzemats en una memòria ROM o EPROM. La majoria de programadors EPROM o emuladors fan servir arxius Intel HEX com a entrada."
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#format-de-larxiu",
    "href": "posts/2010-11-17-format-intel-hex/index.html#format-de-larxiu",
    "title": "Format Intel HEX",
    "section": "",
    "text": "Els arxius Intel HEX són en realitat arxius de text que segueixen el format anomenat “Intel HEX format”.\nCada línia d’aquests arxius conté un registre HEX. Aquests registres estan formats per nombres expressats en base hexadecimal que representen el codi de llenguatge màquina i/o dades constants.\nEls arxius Intel HEX s’utilitzen habitualment per transferir programes i dades que podran ser emmagatzemats en una memòria ROM o EPROM. La majoria de programadors EPROM o emuladors fan servir arxius Intel HEX com a entrada."
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#el-format-dels-registres",
    "href": "posts/2010-11-17-format-intel-hex/index.html#el-format-dels-registres",
    "title": "Format Intel HEX",
    "section": "El format dels registres",
    "text": "El format dels registres\n\nUn arxiu Intel HEX està format per qualsevol nombre de registres HEX. Cada registre està format per 5 camps que segueixen la següent disposició:\n:llaaaatt[dd...]cc\nCada grup de lletres correspon a un camp diferent, i cada lletra representa un únic dígit hexadecimal. Cada camp està format per un mínim de dos dígits hexadecimals (que formen un byte) tal i com es descriu tot seguit:\n\n\n\n\n\n\n\nCamp\nDescripció\n\n\n\n\n:\nMarca l’inici de cada registre Intel HEX\n\n\nll\nÉs el camp de longitud de registre i representa el nombre de bytes de dades (dd) en el registre\n\n\naaaa\nÉs el camp d’adreça que representa l’adreça inicial per al bloc de dades del registre\n\n\ntt\nÉs el camp que representa el tipus de registre, que pot ser qualsevol d’entre els següents casos: 00 - registre de dades  01 - registre de final d’arxiu  02 - Registre d’adreça de segment extensa  04 - Registre d’adreça lineal extensa\n\n\ndd\nÉs el camp de dades que representa un byte de dades. Un registre pot tenir molts bytes de dades. El nombre de bytes de dades del registre ha de coincidir amb la quantitat especificada pel camp ll\n\n\ncc\nÉs el camp de suma de comprovació del registre. Es calcula sumant els valors de totes les parelles de dígits hexadecimals del registre, en mòdul 256, i prenent el complement a 2 del resultat."
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#registres-de-dades",
    "href": "posts/2010-11-17-format-intel-hex/index.html#registres-de-dades",
    "title": "Format Intel HEX",
    "section": "Registres de dades",
    "text": "Registres de dades\nUn arxiu Intel HEX està format per qualsevol quantitat de registres de dades que terminen amb un retorn de línia i un avanç de línia (CR+LF).\nEls registres de dades apareixen així:\n :10246200464C5549442050524F46494C4500464C33\nAquest exemple està codificat tal i com s’indica tot seguit:\n :10246200464C5549442050524F46494C4500464C33\n |||||||||{&lt;-------- DD (Dades) --------&gt;}||\n |||||||||                                ||\n |||||||TT (Tipus de registre)            CC (Suma de comprovació)\n |||AAAA (Adreça inicial)\n |LL (Longitud del registre)\n : (Inici de registre)\nPer tant:\n\n10 és el nombre de bytes de dades en el registre (16 bytes).\n2462 és l’adreça on les dades hauran de ser col·locades a memòria.\n00 és el tipus de registre (un registre de dades en aquest cas).\n33 és la suma de comprovació del registre."
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#registres-dadreça-lineal-extensa-hex386",
    "href": "posts/2010-11-17-format-intel-hex/index.html#registres-dadreça-lineal-extensa-hex386",
    "title": "Format Intel HEX",
    "section": "Registres d’adreça lineal extensa (HEX386)",
    "text": "Registres d’adreça lineal extensa (HEX386)\nEls registres d’adreça lineal extensa són també coneguts com a “registres d’adreça de 32 bits” o registres HEX386. Aquests registres contenen els 16 bits de la part alta (bits 16-31) de l’adreça de les dades.\nEls registres d’adreça lineal extensa presenten sempre dos bytes de dades i apareixen com es mostra en aquest exemple:\n :02000004FFFFFC\nOn:\n\n02 és la quantitat de bytes de dades del registre.\n0000 és el camp d’adreça. En aquests registres aquest camp és sempre 0000.\n04 és el tipus de registre pels registres d’adreça lineal extensa.\nFFFF és la part alta de l’adreça en aquest exemple.\nFC és la suma de comprovació del registre, calculada com a:\n\\[\\overline{ 0x02 + 0x00 + 0x00 + 0x04 + 0xFF + 0xFF } + 0x01 = 0xFC\\]\n\nQuan es llegeix un registre d’adreça lineal extensa, la part alta llegida del registre en el camp de dades s’aplica en el càlcul d’adreça completa dels registres següents de l’arxiu Intel HEX. L’adreça lineal extensa roman efectiva fins que no es canviï per una altra amb un nou registre d’aquest tipus.\nL’adreça absoluta de memòria d’un registre de dades s’obtindrà afegint el camp d’adreça del registre a l’adreça de les dades del registre d’adreça lineal extensa. L’exemple següent il·lustra aquest procés:\n Adreça del camp d'adreça del registre de dades        2462\n Adreça lineal extensa activa                      FFFF\n                                                   --------\n Adreça de memòria absoluta                        FFFF2462"
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#registre-dadreça-de-segment-extensa-hex86",
    "href": "posts/2010-11-17-format-intel-hex/index.html#registre-dadreça-de-segment-extensa-hex86",
    "title": "Format Intel HEX",
    "section": "Registre d’adreça de segment extensa (HEX86)",
    "text": "Registre d’adreça de segment extensa (HEX86)\nEls registres d’adreça de segment extensa, també coneguts com a registres HEX86, contenen els bits 4-19 de l’adreça de segment de les dades.\nEls registres d’adreça de segment extensa sempre presenten dos bytes de dades i apareixen com es mostra aquí:\n :020000021200EA\nOn:\n\n02 és la quantitat de bytes de dades del registre.\n0000 és el camp d’adreça. En aquests registres aquest camp és sempre 0000.\n02 és el tipus de registre pels registres d’adreça de segment extensa.\n1200 és la part alta de l’adreça en aquest exemple.\nEA és la suma de comprovació del registre, calculada com a:\n\\[\\overline{ 0x02 + 0x00 + 0x00 + 0x02 + 0x12 + 0x00 } + 0x01 = 0xEA\\]\n\nQuan es llegeix un registre d’adreça de segment extensa, l’adreça de segment extensa emmagatzemada en el camp de dades es desa i s’aplica als registres llegits a continuació en l’arxiu HEX. El segment d’adreça roman efectiu fins que no es canviï per un altre registre d’adreça de segment.\nL’adreça de memòria absoluta d’un registre de dades s’obté afegint el camp d’adreça del registre amb l’adreça de segment del registre d’adreça de segment extensa. El següent exemple il·lustra aquest procés:\n Adreça del camp d'adreça del registre de dades        2462\n Adreça de segment extensa activa                     1200\n                                                   --------\n Adreça de memòria absoluta                        00014462"
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#registre-de-final-darxiu-eof",
    "href": "posts/2010-11-17-format-intel-hex/index.html#registre-de-final-darxiu-eof",
    "title": "Format Intel HEX",
    "section": "Registre de final d’arxiu (EOF)",
    "text": "Registre de final d’arxiu (EOF)\nUn arxiu Intel HEX ha d’acabar amb un registre de final d’arxiu (EOF, End-Of-File). Aquest registre ha de tenir el valor 01 com a tipus de registre, i sempre apareix com es mostra aquí:\n :00000001FF\nOn:\n\n00 és la quantitat de bytes de dades del registre.\n0000 és el camp d’adreça. En aquests registres aquest camp no té cap significat i és ignorat. Sol fer-se servir 0000.\n01 és el tipus de registre pel registre de final d’arxiu.\nFF és la suma de comprovació del registre, calculada com a:\n\\[\\overline{ 0x00 + 0x00 + 0x00 + 0x01 } + 0x01 = 0xFF\\]"
  },
  {
    "objectID": "posts/2010-11-17-format-intel-hex/index.html#exemple-darxiu-intel-hex",
    "href": "posts/2010-11-17-format-intel-hex/index.html#exemple-darxiu-intel-hex",
    "title": "Format Intel HEX",
    "section": "Exemple d’arxiu Intel HEX",
    "text": "Exemple d’arxiu Intel HEX\nA continuació es mostra l’exemple d’un arxiu complet Intel HEX:\n\n\nexample.hex\n\n:10001300AC12AD13AE10AF1112002F8E0E8F0F2244\n:10000300E50B250DF509E50A350CF5081200132259\n:03000000020023D8\n:0C002300787FE4F6D8FD7581130200031D\n:10002F00EFF88DF0A4FFEDC5F0CEA42EFEEC88F016\n:04003F00A42EFE22CB\n:00000001FF\n\nSi fa les comprovacions, aquest arxiu és tot un arxiu de dades, amb diferents fragments declarats a cada línia de l’arxiu:\n0x0013 : AC 12 AD 13 AE 10 AF 11 12 00 2F 8E 0E 8F 0F 22\n0x0003 : E5 0B 25 0D F5 09 E5 0A 35 0C F5 08 12 00 13 22\n0x0000 : 02 00 23\n0x0023 : 78 7F E4 F6 D8 FD 75 81 13 02 00 03\n0x002F : EF F8 8D F0 A4 FF ED C5 F0 CE A4 2E FE EC 88 F0\n0x003F : A4 2E FE 22\nRedreçant tot el bloc en ordre, posant-lo en línies de 16 bytes per línia, composaria el següent arxiu binari (mostrat aquí en notació hexdump):\n00000000  02 00 23 e5 0b 25 0d f5  09 e5 0a 35 0c f5 08 12  |..#..%.....5....|\n00000010  00 13 22 ac 12 ad 13 ae  10 af 11 12 00 2f 8e 0e  |..\"........../..|\n00000020  8f 0f 22 78 7f e4 f6 d8  fd 75 81 13 02 00 03 ef  |..\"x.....u......|\n00000030  f8 8d f0 a4 ff ed c5 f0  ce a4 2e fe ec 88 f0 a4  |................|\n00000040  2e fe 22                                          |..\"|"
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "",
    "text": "Havíem vist en l’activitat anterior que utilitzar JDBC per accedir a les dades allotjades a una base de dades és una tècnica vàlida i funcional.\nMalgrat tot, havíem vist que malauradament presenta un seguit d’inconvenients. Un d’ells és el fet que per associar objectes Java amb entrades de taules de base de dades, l’obtenció i actualització de les dades dels objectes i de la base de dades s’ha de realitzar manualment programant crides específiques a sentències SQL de tipus SELECT, INSERT, UPDATE o DELETE (les operacions que anomenàvem CRUD).\nAixò és més incòmode encara quan pensem en el procés d’importació i exportació de dades entre la base de dades i els objectes Java en memòria, on hem de programar bucles que realitzin fila a fila (i objecte a objecte) la importació o exportació de dades.\nUna tècnica que redueix l’impacte en la longitud dels nostres programes i millora la redacció de codi és el mapatge objecte-relacional (Object-Relational Mapping, ORM). Aquesta tècnica permet associar objectes Java amb dades de les taules d’una base de dades externa. El mapatge ens permet indicar la correspondència a nivell de camps de taula amb els atributs equivalents d’objecte, de manera que s’automatitza bona part del procés de traducció, eliminant una part de la programació necessària que faríem amb JDBC.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#introducció-al-mapatge-objecte-relacional",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#introducció-al-mapatge-objecte-relacional",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "",
    "text": "Havíem vist en l’activitat anterior que utilitzar JDBC per accedir a les dades allotjades a una base de dades és una tècnica vàlida i funcional.\nMalgrat tot, havíem vist que malauradament presenta un seguit d’inconvenients. Un d’ells és el fet que per associar objectes Java amb entrades de taules de base de dades, l’obtenció i actualització de les dades dels objectes i de la base de dades s’ha de realitzar manualment programant crides específiques a sentències SQL de tipus SELECT, INSERT, UPDATE o DELETE (les operacions que anomenàvem CRUD).\nAixò és més incòmode encara quan pensem en el procés d’importació i exportació de dades entre la base de dades i els objectes Java en memòria, on hem de programar bucles que realitzin fila a fila (i objecte a objecte) la importació o exportació de dades.\nUna tècnica que redueix l’impacte en la longitud dels nostres programes i millora la redacció de codi és el mapatge objecte-relacional (Object-Relational Mapping, ORM). Aquesta tècnica permet associar objectes Java amb dades de les taules d’una base de dades externa. El mapatge ens permet indicar la correspondència a nivell de camps de taula amb els atributs equivalents d’objecte, de manera que s’automatitza bona part del procés de traducció, eliminant una part de la programació necessària que faríem amb JDBC.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#hibernate",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#hibernate",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "2. Hibernate",
    "text": "2. Hibernate\nEl producte lliure Hibernate és un API compatible que podem utilitzar per efectuar tasques de mapatge ORM.\nUtilitzarem una classe POJO (Plain Old Java Object) com a receptacle de les files que provenen de la base de dades, i indicarem a Hibernate que utilitzi aquesta classe per associar-la a la taula de la qual traurem la informació.\nEl cas concret de Hibernate ens ofereix diverses alternatives per tal de realitzar el mapatge, entre les que destaquen dues:\n\nA través d’un arxiu de definició XML que indica quins atributs de la classe POJO corresponen a quines columnes de la taula.\nA través d’anotacions sobre les classes POJO de dades, afegint indicacions que Java utilitzarà per obtenir les associacions d’atributs de classe a columnes de taula.\n\nA més, en el cas concret de Hibernate, se’ns ofereixen tècniques especials per accedir a la informació, construir consultes SQL, o fins i tot un llenguatge propi de consultes anomenat HQL.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#enllaçatinstallació-de-hibernate",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#enllaçatinstallació-de-hibernate",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "3. Enllaçat/instal·lació de Hibernate",
    "text": "3. Enllaçat/instal·lació de Hibernate\nPer a què una aplicació faci ús del API de Hibernate, haurem de disposar de les classes corresponents en un lloc accessible del sistema. Per tant, s’haurà de descarregar des d’Internet la versió més adient (normalment la més moderna).\nAleshores haurem de disposar dels arxius JAR de la distribució de Hibernate al mateix directori de les nostres classes, o bé en un lloc al què apuntarem mitjançant el CLASSPATH en compilar i en executar.\nHibernate ens ofereix multitud de funcionalitats, però nosaltres només utilitzarem les funcionalitats bàsiques. Per tant, hem d’investigar els arxius JAR que apareixen en el directori required del pack d’arxius descarregats.\nAixí doncs, necessitarem els arxius bàsics (requerits) de Hibernate, el connector a la base de dades i també haurem de descarregar la versió adient del API log4j (si volem ajustar paràmetres del logging).\n\n\n\n\n\n\nNota\n\n\n\nEn el moment d’escriure aquestes notes s’ha treballat amb Hibernate-4.1.8 i log4j-1.2.17.\n\n\nPer tant, tenim els següents arxius:\nantlr-2.7.7.jar                                \ndom4j-1.6.1.jar                                \nhibernate-commons-annotations-4.0.1.Final.jar  \nhibernate-core-4.1.8.Final.jar                 \nhibernate-jpa-2.0-api-1.0.1.Final.jar           \njavassist-3.15.0-GA.jar                         \njboss-logging-3.1.0.GA.jar\njboss-transaction-api_1.1_spec-1.0.0.Final.jar\nlog4j-1.2.17.jar\nmysql-connector-java.jar\nSi disposem els arxius en un directori anomenat libs, aleshores podrem compilar manualment els programes Java fent:\njavac -cp .:libs/* Classe.java\nI executar el programa fent:\njava -cp .:libs/* Classe\nObservi que l’especificació del CLASSPATH amb el modificador -cp accepta més d’un camí a arxius o directoris, i en el cas d’arxius JAR és molt més còmode utilitzar el caràcter * per indicar tots els arxius JAR del directori en qüestió.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#configuració-de-hibernate",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#configuració-de-hibernate",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "4. Configuració de Hibernate",
    "text": "4. Configuració de Hibernate\nQuan una aplicació requereix de l’ús de la funcionalitat que ofereix Hibernate, s’ha de configurar l’accés a dades que se li demanarà. Això normalment es fa utilitzant un arxiu de configuració escrit en XML i amb nom per defecte hibernate.cfg.xml. Aquest arxiu conté les directives principals que permeten a Hibernate localitzar i connectar amb el servidor de base de dades i configurar també com s’accedeixen als objectes.\nEn un cas general, aquest arxiu prendrà la forma següent:\nArxiu hibernate.cfg.xml de mostra\n\n\nhibernate.cfg.xml\n\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;!DOCTYPE hibernate-configuration PUBLIC\n          \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n          \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n&lt;hibernate-configuration&gt;\n  &lt;session-factory&gt;\n    &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost/hr&lt;/property&gt;\n    &lt;property name=\"connection.username\"&gt;hr_user&lt;/property&gt;\n    &lt;property name=\"connection.password\"&gt;hr_pass&lt;/property&gt;\n    &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n    &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n    &lt;property name=\"show_sql\"&gt;false&lt;/property&gt;\n    &lt;property name=\"format_sql\"&gt;false&lt;/property&gt;\n    &lt;property name=\"use_sql_comments\"&gt;false&lt;/property&gt;\n    &lt;property name=\"generate_statistics\"&gt;false&lt;/property&gt;\n    &lt;property name=\"hbm2ddl.auto\"&gt;validate&lt;/property&gt;\n    &lt;property name=\"connection.pool_size\"&gt;1&lt;/property&gt;\n    &lt;property name=\"current_session_context_class\"&gt;thread&lt;/property&gt;\n \n    &lt;!-- Mapping files will go here.... --&gt;\n    ...\n\n  &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n\nS’ha indicat a les quatre primeres propietats el lloc on es configura el servidor, el nom de la base de dades, el nom de l’usuari i la contrasenya. Observarà que la sintaxi és la mateixa que en les cadenes JDBC de connexió a base de dades.\nEn el punt que s’ha indicat amb punts suspensius farem esment de les classes i altres elements que haurà de tenir present Hibernate per a l’aplicació concreta que estiguem escrivint. Els exemples mostrats posteriorment indicaran exemples d’ús i com s’omple en cada cas.\nA més, Hibernate generarà un gran volum d’informació de registre i depuració a través de la consola. Si vol desactivar-la haurà de configurar el paquet log4j per a què redueixi (o elimini) la sortida de depuració pel terminal.\nUna de les múltiples formes de fer-ho és a través d’una línia de codi com aquesta:\norg.apache.log4j.Logger.getLogger(\"org.Hibernate\")\n                    .setLevel(org.apache.log4j.Level.FATAL);\nCom veu s’ha fixat el nivell de logging a FATAL, que correspon a errors fatals que normalment avortaran l’execució de l’aplicació. Els possibles cassos que presenta aquesta enumeració són: ALL, DEBUG, ERROR, FATAL, INFO, OFF o WARN. Cadascun d’ells fixa un nivell de generació de logging diferent.\nUna altra tècnica, que permet modificar el comportament sense haver d’escriure codi específic, es mitjançant l’arxiu de propietats log4j.properties. Aquest arxiu permet configurar el paquet log4j en diversos paràmetres.\nUn exemple de configuració de log4j mitjançant arxiu de propietats podria ser el mostrat tot seguit:\n\n\nlog4j.properties\n\n#Log to Console as STDOUT\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n\n#Root Logger\nlog4j.rootLogger=FATAL, stdout",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#exemples-de-hibernate",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#exemples-de-hibernate",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "5. Exemples de Hibernate",
    "text": "5. Exemples de Hibernate\nEn aquesta part parlarem dels 2 projectes que mostren la funcionalitat bàsica de Hibernate amb uns exemples d’ús senzills.\nEls dos exemples mostren, cadascun, diferents formes d’establir els mapatges objecte-relacionals:\n\nEl primer (exemple número 6) mostra com realitzar el mapatge mitjançant arxiu XML\nEl segon (exemple número 7) mostra com fer-ho a través d’annotations.\n\nTots dos exemples utilitzen la mateixa base de dades hr.\n\n\n\n\n\n\nNota\n\n\n\nL’arxiu hr_mysql.sql li permet recuperar la base de dades hr al seu estat original. Recordi que pot executar l’ordre source per executar aquell arxiu SQL manualment des del client de consola de MySQL\n\n\nA més, tots dos exemples fixen un nivell de logging al cas FATAL, mitjançant un arxiu anomenat log4j.properties com el mostrat prèviament i que estarà disponible juntament amb els arxius de codi font de Java, dins del CLASSPATH de l’aplicació.\nEn tots dos casos es contemplaran quatre programes (ubicats en quatre classes amb els seus corresponents mètodes main():\n\nEl primer fa un llistat de tots els treballadors, ordenats pel cognom.\nEl segon mostra, per a cada treballador, en quin departament treballa i la informació del cap de dit departament.\nEl tercer pregunta a l’usuari el id d’un treballador i mostra informació relacionada (arbre jeràrquic de caps i informació del seu departament).\nEl quart pregunta per un id de treballador i li augmenta el sou en una quantitat sol·licitada també a l’usuari.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#exemple-dús-amb-definicions-xml",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#exemple-dús-amb-definicions-xml",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "6. Exemple d’ús amb definicions XML",
    "text": "6. Exemple d’ús amb definicions XML\nEl primer exemple mostrat correspon a un cas d’ús de Hibernate amb mapatge ORM realitzat mitjançant arxiu XML de definició de mapatge.\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple número 6\n\n\nEls arxius font que trobarà al directori són:\n06_hibernate_config_xml/\n    |-- src\n    |     |-- com.flx.ex06\n    |     |     |-- DAOHibernateTest1.java\n    |     |     |-- DAOHibernateTest2.java\n    |     |     |-- DAOHibernateTest3.java\n    |     |     \\-- DAOHibernateTest4.java\n    |     |-- com.flx.ex06.model\n    |     |     |-- Department.java\n    |     |     |-- Employee.java\n    |     |     \\-- HrDAOHibernate.java\n    |     \\-- mappings\n    |           |-- Department.hbm.xml\n    |           \\-- Employee.hbm.xml\n    |-- hibernate.cfg.xml\n    \\-- log4j.properties\nPassem ara a descriure’ls un a un, tot destacant els fets més importants:\n\nClasses com.flx.ex06.model.Employee.java i com.flx.ex06.model.Department.java, que són els POJO bàsics per a les dades de les files de les taules. Aquestes classes són simples POJOs amb tots els atributs declarats, i els mètodes getter i setter associats.\nArxius mappings/Department.hbm.xml i mappings/Employee.hbm.xml que defineixen els mapatges concrets per a les taules i objectes associats en cada cas.\nFixi’s que en aquests arxius s’indica quina classe està associada a quina taula de la base de dades, i posteriorment indiquem els noms dels camps que són utilitzats a la base de dades i al POJO associat. Comprovarà que les definicions de les claus primàries (els camps employeeId a la classe Employee, i departmentId a la classe Department) són una mica més complexes que simplement esmentar els seus noms. Pot descobrir que es marca com a generació automàtica d’identificadors, tal i com les taules d’una base de dades real.\nArxiu hibernate.cfg.xml que configura Hibernate i indica quins són els arxius de mapatge objecte-relacional que es volen efectuar.\nAquest arxiu ja s’havia comentat anteriorment, ara ens hem de centrar en les darreres línies, on declarem que vagi a buscar els arxius XML de definició del mapatge per a les classes Employee i Department.\nArxiu log4j.properties per inhabilitar (configurar) la sortida de missatges (logging) per pantalla excepte en els casos d’error fatal.\nEls programes de prova són com.flx.ex06.DAOHibernateTest1 fins a com.flx.ex06.DAOHibernateTest4.\nClasse com.flx.ex06.model.HrDAOHibernate amb la definició del DAO que serveix per accedir al model de dades.\nAquesta classe incorpora el mètode getSession() per establir la connexió a la base de dades i poder treballar amb ella. El procediment que conté s’ha de fer sempre així. A més, utilitza una tècnica mitjançant la qual no crea una sessió cada vegada que es crida, sinó que només establirà la connexió la primera vegada i després reutilitzarà la connexió establerta a partir d’aquell moment. Si l’aplicació no és molt exigent en rendiment i concurrència, ja és una bona tria.\nLa classe, a més, conté els mètodes que es faran servir en els programes de mostra, amagant la implementació interna de la seva funcionalitat.\n\nEls detalls sobre la manera d’escriure les consultes es deixa per al final del tema.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#exemple-dús-amb-definicions-per-annotations",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#exemple-dús-amb-definicions-per-annotations",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "7. Exemple d’ús amb definicions per annotations",
    "text": "7. Exemple d’ús amb definicions per annotations\nUna variant interessant és la declaració del mapatge per anotacions (annotations), on en comptes de definir les associacions per arxiu XML, simplement introduirem unes marques especialitzades que indiquin directives a Hibernate per detectar automàticament el mapatge sobre la classe POJO.\nEl segon grup d’exemples mostrat correspon a un cas d’ús de Hibernate amb mapatge ORM realitzat mitjançant annotations sobre les classes POJO.\n\n\n\n\n\n\nNota\n\n\n\nObservi ara l’exemple número 7\n\n\nEls arxius font que trobarà al directori són:\n07_hibernate_config_annotations/\n    |-- src\n    |     |-- com.flx.ex07\n    |     |     |-- DAOHibernateTest1.java\n    |     |     |-- DAOHibernateTest2.java\n    |     |     |-- DAOHibernateTest3.java\n    |     |     \\-- DAOHibernateTest4.java\n    |     \\-- com.flx.ex07.model\n    |           |-- Department.java\n    |           |-- Employee.java\n    |           \\-- HrDAOHibernate.java\n    |-- hibernate.cfg.xml\n    \\-- log4j.properties\nObservarà que ara no apareix un arxiu de definició de mapatge, perquè ja està inclòs en les classes Employee i Department. Observi com estan definides ara aquestes classes POJO.\nFixi’s que apareixen annotations que indiquen fets transcendents per al mapatge ORM.\nEn concret, l’anotació @Entity indica que aquesta classe és una entitat que s’ha d’associar a taula de base de dades, mentre que @Table(name=\"nom_de_taula\") indica que el nom de la taula a associar és l’indicat com a argument. Així es pot indicar quina taula correspon a quina entitat.\nDesprés només calen afegir les anotacions @Id i @GeneratedValue sobre el mètode getter de l’atribut que sigui clau primària de la taula. Això és així per permetre la generació automàtica de valors en aquest camp.\nCom veu, les anotacions necessàries en una classe POJO senzilla són ben poques, i força lògiques.\nEn el cas concret dels atributs que són claus foranes, observi que s’han establert les unions de taula a través de codi com el següent:\n@ManyToOne(fetch=FetchType.LAZY)\n@JoinColumn(name=\"departmentId\") \npublic Department getDepartment() { return department; }\nAquestes estructures d’anotació permeten vincular objectes entre taules diferents. Indiquem el nom del camp (departmentId) que serà el de clau forana sobre l’atribut que s’obtindrà una vegada resolta la unió de taules (department).\nL’especificació FetchType.LAZY indica a Hibernate que no cal que es resolgui la unió de taules i es busqui el registre referenciat a menys que sigui imprescindible (es consulti el seu valor). L’alternativa és indicar FetchType.EAGER, que intenta resoldre les relacions sempre que pugui.\nAra, només caldrà configurar Hibernate per tal que utilitzi les anotacions fetes sobre la classe model. Això ho fem des de l’arxiu hibernate.cfg.xml, on veurà que simplement esmentem les classes POJO que defineixen els nostres objectes de dades.\nAmb tot, els programes de prova són exactament iguals, línia a línia. I és que les dues formes de treballar són intercanviables (i es podrien mesclar si es volgués). Tot i que és força habitual treballar sempre amb un mateix esquema dins de la mateixa aplicació.\nEl fet que no hi hagi canvis en el codi és un dels punts forts de Hibernate, que permet canviar (i fins i tot combinar) de model de mapatge ORM segons convingui al desenvolupador.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#persistència-dobjectes-a-la-base-de-dades",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#persistència-dobjectes-a-la-base-de-dades",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "8. Persistència d’objectes a la base de dades",
    "text": "8. Persistència d’objectes a la base de dades\nHibernate, cada vegada que ha de portar una entitat de dades des de la base de dades al domini dels objectes Java, manté una referència a l’entitat original en les taules des d’on s’ha extret. Això, en notació Hibernate, es diu que l’objecte està managed.\nQuan un objecte és managed si volem modificar-lo, simplement haurem de cridar al mètode Session.update(objecte), de la mateixa manera que si volem eliminar-lo de la base de dades, només caldrà cridar el mètode Session.delete(objecte). Hibernate farà tota la resta.\nUna característica interessant de Hibernate és que ens permet evitar l’ús de sentències SQL en multitud de situacions:\n\nQuan volem inserir a la taula un nou registre a partir d’un objecte existent, utilitzem el mètode Session.save(objecte) i Hibernate s’encarregarà de generar l’ordre INSERT adient.\nQuan volem eliminar de la taula un registre existent que tenim associat en un objecte, utilitzarem el mètode Session.delete(objecte), i Hibernate generarà l’ordre DELETE corresponent.\nQuan volem modificar un registre de la taula, utilitzarem el mètode Session.update(objecte), i Hibernate generarà l’ordre UPDATE adequada.\n\nA més, Hibernate ens ofereix el control de transaccions bàsic, de manera que els canvis no es faran efectius definitivament en la base de dades mentre no tanquem la transacció. Les transaccions normalment es delimiten així:\nTransaction tx = session.beginTransaction();\n...\ntx.commit();  // tx.rollback();\nAixò també es pot programar així:\nsession.beginTransaction();\n...\nsession.getTransaction().commit();\n// session.getTransaction().rollback();\nPer tant, tota l’operativa està protegida pels mecanismes convencionals de transaccions.\nPer altra banda, observi que no hem de fer cap procediment especial per controlar la replicació de dades entre memòria i base de dades. Quan tanquem una transacció amb la crida commit() les dades són portades des de memòria a la base de dades sense que sigui necessari codificar cap procediment especial.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#construccions-de-consultes-sql-hql-i-criteria",
    "href": "posts/2013-07-01-BD05-hibernate-mapatge-objecte-relacional/index.html#construccions-de-consultes-sql-hql-i-criteria",
    "title": "Hibernate i el mapatge objecte-relacional",
    "section": "9. Construccions de consultes SQL, HQL i Criteria",
    "text": "9. Construccions de consultes SQL, HQL i Criteria\nQuan volem realitzar una consulta de selecció (SELECT) és quan tenim moltes més opcions i possibilitats.\nLes tres opcions més importants que ofereix Hibernate són:\n\nEnviar sentències SQL construïdes manualment (native SQL query)\nUtilitzar un objecte Criteria per construir la sentència SQL a través de mètodes específics\nUtilitzar el llenguatge HQL propi de Hibernate per construir la sentència SQL\n\n\n9.1. Consultes amb SQL\nPer generar una consulta SQL amb Hibernate, només hem d’escriure la sentència SQL dins d’una crida a la funció Session.createSQLQuery(). Aquest mètode ens retorna un objecte SQLQuery, al qual podem demanar el resultat de la seva execució invocant SQLQuery.list():\nSQLQuery q = session.createSQLQuery(\"SELECT * FROM employees\");\nList&lt;Employee[]&gt; result = q.list();\nEl valor retornat és una llista de files, on cada fila és un array indexat que ens permetrà accedir a les diferents columnes de resultat. Haurem d’utilitzar meta-dades per descobrir els tipus dels diferents elements en temps d’execució.\nAixò no és res més que una consulta com les que realitzàvem amb JDBC. Per associar i obtenir objectes a partir de la base de dades hem d’utilitzar una altra via: hem de cridar el mètode SQLQuery.addEntity() per indicar l’entitat que s’espera rebre d’aquesta consulta i així obtenir la llista d’objectes ja en la forma que ens interessa:\nSQLQuery q = session.createSQLQuery(\"SELECT * FROM employees\")\n                .addEntity(Employee.class);\n@SuppressWarnings(\"unchecked\")\nList&lt;Employee&gt; result = q.list();\nObservi que s’ha fet una referència a la classe de l’entitat amb l’operador Employee.class.\nObservarà també que s’ha afegit la línia @SuppressWarnings(\"unchecked\") per demanar al compilador de Java que no generi un avís sobre la transformació de tipus que es produeix en l’obtenció de la llista de resultats de la consulta (aquesta directiva només afecta a la línia immediatament a continuació o el bloc iniciat en ella). Malauradament no hi ha una altra manera ràpida i senzilla per evitar l’aparició d’aquest missatge d’avís generat pel compilador i s’ha de recórrer a aquest mètode “brut” per evitar-lo: els avisos són normalment signes d’un mal disseny o d’una possible font de problemes a la llarga. En aquest cas malauradament no depèn de nosaltres sinó de la forma en què Hibernate està codificat amb la funció SQLQuery.list().\nSigui com sigui ara disposem de la llista d’objectes ubicats en memòria i podem utilitzar tota la potència de Java per manipular-los en memòria i realitzar les operacions necessàries de la nostra aplicació.\n\n\n9.2. Consultes amb Criteria\nHibernate ens ofereix un mecanisme molt interessant per no fer servir consultes SQL en el llenguatge natiu de la base de dades. De fet, no té sentit fer consultes en SQL natiu en un entorn que ens permet no dependre del motor concret de base de dades utilitzat!\nAixí doncs, una primera solució és la que es mostra aquí. En ella, tota consulta es fonamenta en l’ús d’un seguit de mètodes que pengen de la classe Criteria i que ens permeten anar construint la consulta a passos.\nVegem un exemple:\nCriteria c = session.createCriteria(Employee.class)\n                    .add(Restrictions.or(\n                        Restrictions.like(\"lastname\", \"K%\"),\n                        Restrictions.like(\"lastname\", \"M%\")\n                    )).\n                    .add(Restrictions.isNotNull(\"commissionPct\"))\n                    .addOrder(Order.asc(\"lastname\"));\n@SuppressWarnings(\"unchecked\")\nList&lt;Employee&gt; emps = c.list();\n...\nObservi com es van afegint elements a la consulta Criteria mitjançant el mètode add() i que disposem d’una gran col·lecció de paràmetres de filtrat de registres basats en la classe Restrictions. Consulti la documentació oficial per a més informació.\n\n\n9.3. Consultes amb HQL\nLes consultes que utilizen el llenguatge HQL (Hibernate Query Language) tenen una dinàmica semblant a la de SQL estàndard, però modifica lleugerament algunes expressions en alguns casos concrets.\nEl procediment per construir una sentència HQL i executar-la pot ser tant senzill com el següent cas:\nString hql = \"SELECT e FROM employees e WHERE lastname LIKE 'K%'\";\n@SuppressWarnings(\"unchecked\")\nList&lt;Employee&gt; emps = session.createQuery(hql).list();\nFins i tot podem realitzar tasques d’assignació de paràmetres, com:\nString hql = \"SELECT e FROM employees e WHERE lastname= :cognom\";\n@SuppressWarnings(\"unchecked\")\nList&lt;Employee&gt; emps = session.createQuery(hql)\n                        .setParameter(\"unnom\", \"King\")\n                        .list();\nAmb HQL també podem realitzar INSERT, DELETE i UPDATE, amb també una sintaxi semblant a l’estàndard SQL:\nString hql = \n    \"UPDATE employees e SET e.firstname = :nomNou WHERE e.firstname = :nomAntic\";\nint updatedEntities = \n    session.createQuery( hql )\n        .setString( \"nomNou\", \"Steven\" )\n        .setString( \"nomAntic\", \"Stefan\" )\n        .executeUpdate();\nConsulti la documentació de JBoss/Hibernate per a més informació sobre HQL.",
    "crumbs": [
      "Inici",
      "5 Hibernate i ORM"
    ]
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html",
    "href": "posts/2013-11-11-guia-rapida-git/index.html",
    "title": "Guia ràpida de Git",
    "section": "",
    "text": "Git és una aplicació extraordinària per mantenir el control de versions d’un projecte de desenvolupament. Permet tant el control de versions local com remot, permetent de pas el treball col·laboratiu entre diferents programadors en un mateix projecte. En aquest post intento resumir les funcionalitats bàsiques de Git a través d’uns exemples clars i entenidors dels diferents casos d’ús més habituals."
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#ús-bàsic",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#ús-bàsic",
    "title": "Guia ràpida de Git",
    "section": "Ús bàsic",
    "text": "Ús bàsic\n\nConstruïm un projecte de prova amb alguns arxius:\nmkdir -p testgit/proj\ncd testgit/proj                             # Com si fos un projecte...\necho \"Hola\" &gt; README.txt                    # ... amb alguns arxius\necho \"Altre\" &gt; altre.txt\necho \"// Arxiu de codi font\" &gt; Classe.java\nConsultem la informació que disposa Git sobre nosaltres:\ngit config --list\ngit config user.name                        # Només aquesta dada\nPodem canviar els paràmetres que volguem:\ngit config --global user.name \"Linus Torvalds\"\ngit config --global user.email linus.torvalds@cesf.es\nQuan necessitem ajuda sobre qualsevol ordre de Git, podem invocar-la a través de l’ajuda:\ngit help config\nAra afegim la gestió de projectes amb Git:\ngit init\nApareix un directori ocult amb nom .git en el directori del projecte.\nAra podem afegir els arxius que hem creat a la gestió de projectes. Aquest procés s’anomena staging:\ngit add README.txt\ngit add *.java\ngit add .                               # Afegeix directori i subdirectoris\nAra comprovem els arxius pendents de ser gestionats:\ngit status\necho \"// Segon arxiu font\" &gt; Classe.java\necho \"Més text\" &gt;&gt; README.txt \ngit status                              # Marca els canvis no gestionats\ngit add .\ngit status\nUn cop afegits els arxius desitjats, ja podem enviar (commit) els canvis disposats per ser processats:\ngit commit -m \"Primera salvaguarda\"\nAra aquests canvis han estat processats i el sistema els ha desat. El projecte ara passa a un estat “net”, perquè tots els arxius estan igual que al dipòsit:\ngit status\nPodem treballar amb la gestió de tot un directori encara que no volguem que tots els arxius siguin gestionats per Git. Això es pot aconseguir mantenint un arxiu anomenat .gitignore a l’arrel del projecte:\necho \"aaa\" &gt; Main.class             # Com si s'hagués compilat \necho \"bbb\" &gt; Classe.class           # Com si s'hagués compilat\necho \"Més text\" &gt;&gt; README.txt\ngit status                          # Surten aquests arxius\n\necho \"*.[oa]\" &gt; .gitignore\necho \"*~\" &gt;&gt; .gitignore\necho \"*.class\" &gt;&gt; .gitignore\ngit status                          # Surt el .gitignore però no els compilats\n\ngit add .                           # Acceptem tots els canvis i els gestionem\ngit status\nPodem veure els canvis pendents de ser processats:\ngit diff --staged\nUn cop afegits els arxius desitjats, ja podem enviar (commit) els canvis disposats per ser processats:\ngit commit -m \"Segona salvaguarda: `date`\"\nEs poden gestionar els arxius presents al dipòsit Git mitjançant les ordres git rm i git mv:\ngit rm altre.txt\ngit rm \\*~\ngit mv README.txt README\ngit status\ngit commit -a -m \"Tercera: `date`\"      # -a equival a fer \"git add .\" abans\nPodem veure l’històric de canvis:\ngit log\ngit log -p -2\ngit log --stat\ngit log --pretty=format:\"%h - %an, %ar : %s\"\ngit log --pretty=format:\"%h %s\" --graph\nPodem controlar els arxius que estan en staging (procés unstaging):\necho \"arxiu auxiliar\" &gt; doc.txt\ngit status\ngit add .                               # Stage de tot el directori\ngit status\ngit reset HEAD doc.txt                  # Treure'l del \"staged area\" (Unstaging)\ngit status\nrm doc.txt\nTambé podem anular canvis d’un arxiu:\necho \"Tercera línia\" &gt;&gt; README\ngit status\ngit checkout -- README                  # Desfer edició abans del \"staging\"\ncat README\ngit status\nLog bonic:\nalias gl=\"git log --graph --abbrev-commit --decorate --date=relative \\\n--format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) \\\n%C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' \\\n--all\"\n\ngl\n\n\n\nCaptura d’una sortida de l’àlies gl"
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#diverses-línies-de-desenvolupament",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#diverses-línies-de-desenvolupament",
    "title": "Guia ràpida de Git",
    "section": "Diverses línies de desenvolupament",
    "text": "Diverses línies de desenvolupament\nEl desenvolupador principal pot voler generar una branca del projecte on provar alguna tècnica nova.\n\nGenerar una nova branca i activar-la:\ngit branch prova1                       # Definim la branca, però no l'activem\ngit checkout prova1                     # Canviem a aquesta branca\nFem canvis i mostrem canvis al resum:\ndate &gt; actual.txt\ngit add .\ngit commit -m \"`date`\"\ngit log --pretty=format:\"%h %s\" --graph\nSi ho mirem des de la branca principal:\ngit checkout master\ngit log --pretty=format:\"%h %s\" --graph\nVeurem que el darrer canvi no apareix. En aquesta branca no consta el canvi.\nAra el projecte principal evoluciona:\necho \"arxiu\" &gt; nouarxiu.txt             # L'últim checkout ens ha tornat a \"master\"\ngit add .\ngit commit -m \"`date`\"\nPodem veure tot el flux de canvis entre les diferents branques amb modificadors de git log:\ngit log --graph --oneline --all\ngl\nSi els canvis són compatibles (no hi ha conflictes), les branques poden ser reunificades quan es vulgui:\ngit merge prova1 -m \"Reunificació amb branca prova1\"\nAra generarem una situació de conflicte:\ngit branch prova2\necho \"Línia en master\" &gt;&gt; README\ngit commit -a -m \"`date`\"\ngit checkout prova2\necho \"Línia en prova2\" &gt;&gt; README\ngit commit -a -m \"`date`\"\ngit checkout master\ngit merge prova2 -m \"Reunificació amb branca prova2\"\nL’arxiu README quedarà modificat. Haurem d’editar-lo manualment i definir quina versió de les mostrades és l’acceptada. Un cop editat l’arxiu amb conflicte, s’afegirà al staging i es farà el commit per acceptar-lo a la branca unificada:\ngit add README\ngit commit -m \"Reunificació amb branca prova2\"\ngl\nLes branques poden eliminar-se si es desitja. Per fer-ho han d’haver sofert un procés de merge amb la seva branca mare o ens avisarà del fet:\ngit checkout master                 # tornem a la branca master\ngit branch -d prova1                # cap problema\ngit branch -d prova2                # se'ns queixarà\ngit branch -D prova2                # fem l'eliminació forçada"
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#restauració-darxius",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#restauració-darxius",
    "title": "Guia ràpida de Git",
    "section": "Restauració d’arxius",
    "text": "Restauració d’arxius\nSi sabem que un determinat arxiu ha estat modificat en algun moment i que hem perdut alguns blocs de codi interessants accidentalment o per descuit, sempre podrem restaurar-lo a aquell estat.\n\nGenerem una situació en què necessitem fer aquesta operació de restauració.\ngit checkout prova2\necho \"Contingut interessant...\" &gt; nou.txt\ngit add .\ngit commit -m \"nou arxiu afegit\"\necho \"Contingut perdut!\" &gt; nou.txt\ngit add .\ngit commit -m \"arxiu malbaratat\"\nLa segona versió de l’arxiu substitueix el contingut que s’havia afegit a la primera versió. Aquí tenim el punt en què necessitem restaurar a la primera versió.\nPer poder restaurar l’arxiu necessitem saber en quin commit de quina branca es trobava aquell arxiu. Això ho podem descobrir combinant git log i git diff:\n$ git log\n* ce10391 - (17 seconds ago) malament - Fèlix Galindo Allué (HEAD, prova2)\n* 93c2987 - (36 seconds ago) bo - Fèlix Galindo Allué\n* 616ab1b - (3 days ago) nou arxiu - Fèlix Galindo Allué (prova1)\n* 601416b - (4 days ago) dijous,  7 de novembre de 2013, 17:44:37 CET - Fèlix Ga\n* 2026f1d - (4 days ago) dijous,  7 de novembre de 2013, 17:34:52 CET - Fèlix Ga\n* a99796e - (4 days ago) Primera salvaguarda - Fèlix Galindo Allué\n\n$ git diff 93c2987\ndiff --git a/nou.txt b/nou.txt\nindex 6c3a082..25a7eab 100644\n--- a/nou.txt\n+++ b/nou.txt\n@@ -1 +1 @@\n-bo\n+malament\nCom veiem, en el commit identificat com a 93c2987 teníem la pèrdua de línies de l’arxiu. Volem restaurar fins a aquella versió d’aquell arxiu.\nAra podem restaurar l’arxiu fent ús de git checkout:\ngit checkout 93c2987 nou.txt\nmore nou.txt                    # veurem la versió bona (antiga)\nL’arxiu ha estat restaurat a aquell estat. Si volem fixar-lo haurem de fer un nou commit, perquè ara com ara és com si l’haguéssim editat manualment:\ngit status                      # ens dirà que hi ha canvis pendents\nSi al final no volem desar-lo d’aquella manera i volem tornar a la darrera versió desada, simplement farem:\ngit checkout HEAD nou.txt\nmore nou.txt                    # veurem la versió dolenta (última)\ngit status                      # ens dirà que res ha canviat"
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#entorn-de-diversos-desenvolupadors",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#entorn-de-diversos-desenvolupadors",
    "title": "Guia ràpida de Git",
    "section": "Entorn de diversos desenvolupadors",
    "text": "Entorn de diversos desenvolupadors\nEl control de versions de Git vist fins ara és el corresponent a projectes locals (aquells que són realitzats en un sol directori d’una única màquina).\nHem de considerar dues situacions comunes:\n\nPotser volem que un projecte pugui evolucionar incorporant nous desenvolupadors que desenvolupin mòduls o variants del software independentment i incorporar els seus canvis segons uns objectius o validant les seves característiques afegides al projecte original.\nDe vegades, potser un sol desenvolupador pot estar desenvolupant el seu únic projecte en diferents màquines (ordinador fix - ordinador portàtil - ordinador de la feina).\n\nTots dos casos ens obliguen a disposar d’un control de versions remot, és a dir, que puguem bolcar els nostres canvis a un lloc comú i disponible des de diversos equips i/o ubicacions. Això també és permès amb Git.\nLes ubicacions disponibles per al remote del nostre projecte pot prendre diferents formes segons el cas:\n\nUn servidor especialitzat amb servei SSH i usuaris definits per a què hi puguin accedir,\nUn servidor especialitzat públic, com GitHub o Gitlab, que ofereix servei d’hostatge de projectes públic i/o privats,\nUn directori compartit en xarxa, muntat en els diferents equips dels diferents desenvolupadors com a unitat de xarxa,\nUn directori vinculat a algun servei d’emmagatzematge en el núvol, com Dropbox o Google Drive.\n\nEn tots els casos disposarem d’una ruta o camí que indicarà la ubicació del projecte. Serà mitjançant aquesta ruta que el projecte podrà ser duplicat en altres equips per altres desenvolupadors.\nExemples de rutes de projecte:\n\n\n\n\n\n\n\nTipus\nExemple\n\n\n\n\nGitlab (via HTTPS)\nhttps://gitlab.com/felix.galindo/jekyll-liquid-latex-plugin.git\n\n\nGitlab (via SSH)\ngit@gitlab.com:felix.galindo/jekyll-liquid-latex-plugin.git\n\n\nServidor SSH privat\nuser:pass@servidor.com:/projectes/projecte.git\n\n\nDirectori local\n/projectes/projecte.git\n\n\nDirectori Dropbox\n~/Dropbox/projectes/project.git\n\n\n\nSuposarem ara un projecte ubicat a un directori local privat d’un usuari com a mostra per entendre la funcionalitat bàsica dels remote.\n\nCreem un projecte buit en el lloc on volem dipositar-lo (remote):\nmkdir -p ~/Dropbox/remotes\ngit init --bare ~/Dropbox/remotes/projecte.git\nls ~/Dropbox/remotes/projecte.git\nVeurem tota una estructura de directoris que allotjaran la versió remota del nostre projecte.\nAra crearem la versió local on editarem el projecte:\ncd ~/testgit\ngit clone ~/Dropbox/remotes/projecte.git\nls\ncd projecte\nls -la                  # Veurem el directori .git habitual\nEl projecte queda vinculat al remote origen, de manera que les variables corresponents prenen els valors adients:\ngit config --list       # Veurem remote.origin.url, per exemple\nTambé existeix l’ordre git remote per controlar les variables remotes. Podem utilitzar-lo per llistar els valors actuals:\ngit remote -v\ngit remote show origin\nAra ja podem començar a treballar en el nostre projecte:\necho \"Documentació\" &gt; README.md\nmkdir src\necho \"// Arxiu font\" &gt; src/Main.java\ngit add .\ngit commit -m \"Commit inicial\"\ngl                      # Veurem el nostre commit\nQuan hem acabat d’editar localment, podem “pujar” els canvis al servidor remot amb una operació push:\ngit push origin master\nAmb origin indiquem que el push s’ha d’efectuar contra el projecte origen de la clonació, mentre que amb master indiquem que ho faci a la branca principal del projecte. Això és obligatori només la primera vegada que es fa el push. Les següents ho recorda si no ho canviem passant els arguments a git push:\necho \"Millorat\" &gt;&gt; README.md \ngit add .\ngit commit -m \"Millores en docs\" \ngit push\nSuposem ara que un segon desenvolupador vol o ha de participar en el projecte de software. Per la seva banda, realitzarà unes tasques similars a les anteriorment descrites:\ngit config --global user.name \"Jordi Galindo López\"\ngit config --global user.email \"jordi@flx.cat\"\ncd ~/testgit\ngit clone ~/Dropbox/remotes/projecte.git jordi\ncd jordi\ngl\nAra aquest desenvolupador farà canvis:\necho \"Hola\" &gt;&gt; jordi.txt\ngit add .\ngit commit -m \"Afegit jordi.txt\"\ngit push origin master\ngl\nEl procés d’edició i millora del software pot continuar indefinidament per ambdues bandes. El problema és quan s’intenta fer un push abans d’adquirir els canvis fets per l’altre(s) usuari(s) involucrat al projecte:\ncd ../projecte\ngit config --global user.name \"Linus Torvalds\"\ngit config --global user.email \"linus.torvalds@cesf.es\"\necho \"Més documentació\" &gt;&gt; README.md\ngit add .\ngit commit -m \"Documentació millorada\"\ngit push                                # GENERARÀ UN ERROR\nEl primer desenvolupador ha intentat fer un push quan encara no ha descarregat els darrers canvis fets pel segon desenvolupador (que també havia fet un push). En aquests casos, el desenvolupador que intenti fer el segon push ha de descarregar els canvis fets per l’altre primer, amb una operació pull:\ngit pull            # Ens farà editar un missatge específic\ngit push            # ARA SÍ FUNCIONARÀ\ngl                  # Veuràs la unió com si fos un \"merge\"\nPodem utilitzar git pull --no-edit per a què faci servir un missatge preconfigurat del tipus “Merge branch … of …”.\n\nExisteix l’ordre git fetch, que fa el mateix que git pull, però no té en compte les branques del projecte. Normalment es fa servir git pull per ser més potent que l’altra."
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#tags",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#tags",
    "title": "Guia ràpida de Git",
    "section": "Tags",
    "text": "Tags\nSuposem que el nostre projecte ha arribat a un punt clau del seu desenvolupament. Diguem-ne que tenim una “versió” completada o que el punt on estem és un punt important a on potser voldrem tornar més endavant.\nEn aquests casos podem fer ús dels tags per realitzar etiquetes sobre determinats commits que ens siguin especialment destacables.\n\nSuposem que continuem en el projecte de software anterior i crearem un tag:\ncd ~/testgit/projecte\ngl\ngit tag -a v1.0 -m \"Versió 1.0\"         # Creem el tag\ngl\nEn el log hem d’observar la presència de la forma abreujada v1.0 tal i com si fos el nom d’una branca.\necho \"més edició\" &gt;&gt; README.md\ngit add .\ngit commit -m \"millores\"\ngl                                      # Veurem el tag en l'històric\nPodem extreure informació de la versió indicada pel tag fent:\ngit show v1.0\nSuposem que continuem editant i creant versions:\ngit tag -a v1.1 -m \"Versió 1.1\"\necho \"Més encara\" &gt;&gt; README.md \ngit add .\ngit commit -m \"més millores\"\nEn aquest moment ens interessaria veure la llista de tags del nostre projecte:\ngit tag\nEls tags no són pujats de manera automàtica en fer push. Podem indicar si volem pujar la definició d’un tag afegint el seu nom:\ngit push origin v1.1\nO també podem indicar que es pugin tots els tags definits localment:\ngit push --tags\nÉs possible que un determinat desenvolupador pugui clonar un projecte concret en l’estat que es trobava en un cert tag. Per fer-ho es farà servir la mateixa notació que si es tractés d’una selecció de branca:\ncd ~/testgit\ngit clone ~/Dropbox/remotes/projecte.git -b v1.0 projecte_v1.0\nEn realitat, això equival a clonar el projecte complet i canviar a la posició del tag indicat mitjançant una operació git checkout."
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#githubgitlab",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#githubgitlab",
    "title": "Guia ràpida de Git",
    "section": "GitHub/Gitlab",
    "text": "GitHub/Gitlab\nGitHub i Gitlab ens ofereixen la possibilitat d’allotjar projectes de desenvolupament tot definint els nostres remotes en el seu servidor.\nSegons el tipus de compte que creem, podrem disposar de projectes públics (versió gratuïta) o privats (versió de pagament).\nLa diferència principal respecte a tot el que s’ha vist fins ara és que el procés de push i pull es realitza sobre un únic remote.\nSi un desenvolupador vol clonar el projecte de manera pública, podrà fer-ho amb el procés que anomenarem “fork”. El procés de fork crearà un projecte nou, clonació del projecte original, on el desenvolupador disposarà de tota la infraestructura per evolucionar el seu clon del projecte original. Es perdrà el seguiment del projecte original, però el desenvolupament serà possible.\nQuan aquest desenvolupador vulgui comunicar els canvis que ha fet sobre el projecte original al desenvolupador del projecte principal, ho farà mitjançant una operació de “pull request”, en què el desenvolupador original verificarà els canvis fets i validarà si vol o no adquirir-los.\nSi el desenvolupador original accepta les modificacions, els canvis seran afegits al projecte original igual que si es tractés d’un merge convencional. El projecte original haurà crescut en complexitat i podrà continuar sent desenvolupat com a línia principal i original del projecte."
  },
  {
    "objectID": "posts/2013-11-11-guia-rapida-git/index.html#referències-externes",
    "href": "posts/2013-11-11-guia-rapida-git/index.html#referències-externes",
    "title": "Guia ràpida de Git",
    "section": "Referències externes",
    "text": "Referències externes\n\nLloc oficial de Git: http://git-scm.com/doc\nReferència ràpida: http://gitref.org/\nLloc de GitHub: https://github.com/\nLloc de Gitlab: https://gitlab.com/"
  },
  {
    "objectID": "posts/2013-12-04-bucles-en-el-sed/index.html",
    "href": "posts/2013-12-04-bucles-en-el-sed/index.html",
    "title": "Bucles en un sed",
    "section": "",
    "text": "Parlant amb un company, em presenta la següent situació:\n\nTenim un nombre a l’estil 12345678.12 i volem que ens insereixi els grups de milers (amb un caràcter de coma) cada tres dígits segons la notació habitual. Requeriment: s’ha de fer amb línia d’ordres i amb l’ordre sed. {: .quotation }\n\nEl problema és que, ho pensi com ho pensi, no trobo la manera de codificar-ho en una única sentència de sed sense fer bucles.\nFer la incorporació de l’últim punt de milers és fàcil. Només cal buscar un bloc de 4 dígits numèrics consecutius abans d’un punt de decimal o milers, i inserir la coma de milers entre el primer i el segon. Quelcom això:\necho \"1234567890.12\" | sed -E 's/([0-9])([0-9]{3,3}[.,])/\\1,\\2/g'\nEl resultat obtingut és 1234567,890.12.\nPerò per poder fer la conversió de tota la cadena s’hauria d’implantar un bucle que executi aquest procés mentre quedin blocs de 4 dígits seguits… Lleig!\nLa solució l’he trobada descobrint que sed accepta un pseudo-llenguatge de programació que inclou bucles en l’expressió a executar!!!\nEl format d’un bucle és així:\n: etiqueta\n/condició/ {\n    ordre\n    ordre\n    ...\n    b etiqueta\n}\nLa directiva b és la que força que es torni a l’etiqueta inicial, fent un bucle on es valida la condició indicada.\nEn el cas presentat, la condició és que quedin blocs de 4 dígits seguits. Per tant, la solució a aquest repte és la següent:\necho \"1234567890.12\" | sed -E '\n    :loop\n    /[0-9]{4,4}/ {\n        s/([0-9])([0-9]{3,3}[.,])/\\1,\\2/g\n        b loop\n    }\n'\nEl resultat és ara el desitjat: 1,234,567,890.12.\nRepte resolt!\nFonts d’informació addicionals:\n\nProgramming patterns in sed\nManual en línia de sed"
  },
  {
    "objectID": "posts/2013-12-04-bucles-en-el-sed/index.html#cas-dús",
    "href": "posts/2013-12-04-bucles-en-el-sed/index.html#cas-dús",
    "title": "Bucles en un sed",
    "section": "",
    "text": "Parlant amb un company, em presenta la següent situació:\n\nTenim un nombre a l’estil 12345678.12 i volem que ens insereixi els grups de milers (amb un caràcter de coma) cada tres dígits segons la notació habitual. Requeriment: s’ha de fer amb línia d’ordres i amb l’ordre sed. {: .quotation }\n\nEl problema és que, ho pensi com ho pensi, no trobo la manera de codificar-ho en una única sentència de sed sense fer bucles.\nFer la incorporació de l’últim punt de milers és fàcil. Només cal buscar un bloc de 4 dígits numèrics consecutius abans d’un punt de decimal o milers, i inserir la coma de milers entre el primer i el segon. Quelcom això:\necho \"1234567890.12\" | sed -E 's/([0-9])([0-9]{3,3}[.,])/\\1,\\2/g'\nEl resultat obtingut és 1234567,890.12.\nPerò per poder fer la conversió de tota la cadena s’hauria d’implantar un bucle que executi aquest procés mentre quedin blocs de 4 dígits seguits… Lleig!\nLa solució l’he trobada descobrint que sed accepta un pseudo-llenguatge de programació que inclou bucles en l’expressió a executar!!!\nEl format d’un bucle és així:\n: etiqueta\n/condició/ {\n    ordre\n    ordre\n    ...\n    b etiqueta\n}\nLa directiva b és la que força que es torni a l’etiqueta inicial, fent un bucle on es valida la condició indicada.\nEn el cas presentat, la condició és que quedin blocs de 4 dígits seguits. Per tant, la solució a aquest repte és la següent:\necho \"1234567890.12\" | sed -E '\n    :loop\n    /[0-9]{4,4}/ {\n        s/([0-9])([0-9]{3,3}[.,])/\\1,\\2/g\n        b loop\n    }\n'\nEl resultat és ara el desitjat: 1,234,567,890.12.\nRepte resolt!\nFonts d’informació addicionals:\n\nProgramming patterns in sed\nManual en línia de sed"
  },
  {
    "objectID": "posts/2013-07-02-BD07-oodbms-amb-db4o-i-java/index.html",
    "href": "posts/2013-07-02-BD07-oodbms-amb-db4o-i-java/index.html",
    "title": "OODBMS amb db4o i Java",
    "section": "",
    "text": "Un altre element que veurem en aquest curs és el de les bases de dades orientades a objectes. Aquestes bases de dades treballen directament sobre objectes que són portats directament entre l’aplicació i la base de dades.\nLa diferència amb el model tradicional amb mapatge objecte-relacional (o el cas de les bases de dades objecte-relacionals), és que ara l’objecte es desa tal qual a la base de dades.\nEn realitat, això no és exactament així, cada producte de base de dades orientada a objectes cobrirà aquesta funcionalitat amb algun format binari propietari o treballarà sobre la serialització dels objectes a emmagatzemar.\nEn el nostre cas treballarem amb db4o, un producte senzill, petit i portable que demostra una bona eficiència i rendiment i que emmagatzema els objectes en un arxiu de disc que serà la base de dades.\nL’avantatge d’aquest producte és que és lliure, consisteix en uns arxius JAR que podem afegir als nostres projectes, i que presenta una col·lecció de funcions reduïda i útil per a realitzar les operacions CRUD bàsiques sobre els objectes que ha de manegar, a més d’oferir-nos tres mecanismes de consulta avançats:\n\nQBE (Query By Example): Consultes descrites en termes d’allò que s’espera obtenir.\nNative Query: Consultes utilitzant comparacions en els mateixos objectes.\nSODA: Consultes en llenguatge natiu de db4o.\n\nMés endavant s’estudiaran aquests casos. Ara vegem els elements bàsics en la programació d’una aplicació basada en db4o.\n\n\n\n\n\n\nNota\n\n\n\nPer a la realització d’aquests apunts s’ha treballat sobre db4o en la seva versió 8.0.\n\n\n\n\nEn primer lloc, l’aplicació haurà de disposar de les llibreries necessàries per a la seva completa operativa. Això implica els següents arxius:\nant.jar\nbloat-1.0.jar\ndb4o-8.0.249.16098-all-java5.jar\ndb4o-8.0.249.16098-bench.jar\ndb4o-8.0.249.16098-core-java5.jar\ndb4o-8.0.249.16098-cs-java5.jar\ndb4o-8.0.249.16098-cs.optional-java5.jar\ndb4o-8.0.249.16098-db4ounit-java5.jar\ndb4o-8.0.249.16098-instrumentation-java5.jar\ndb4o-8.0.249.16098-nqopt-java5.jar\ndb4o-8.0.249.16098-optional-java5.jar\ndb4o-8.0.249.16098-osgi-java5.jar\ndb4o-8.0.249.16098-osgi-test-java5.jar\ndb4o-8.0.249.16098-taj-java5.jar\ndb4o-8.0.249.16098-tools-java5.jar\nAra, una vegada disposem d’aquestes llibreries en el lloc adient, el nostre programa podrà utilitzar les funcionalitats de db4o per afegir persistència d’objectes.\nPer connectar amb una base de dades existent (o crear-ne una de nova si no existia abans), només caldrà fer una crida com la següent:\nObjectContainer db = Db4oEmbedded.openFile(\n                        Db4oEmbedded.newConfiguration(), \n                        dbFile);\non dbFile representa un String amb el nom de l’arxiu on estigui (o vulgui crear-se) la base de dades d’objectes.\nQuan hem acabat de fer les accions que siguin oportunes amb la base de dades, hem de tancar la base de dades mitjançant una simple crida com la següent:\ndb.close();\nD’aquesta manera s’alliberaran tots els recursos que db4o hagi ocupat per mantenir la base de dades activa i connectada, a més de buidar al disc les últimes modificacions pendents de ser fixades.\n\n\n\nQuant a l’execució de consultes, les de selecció d’objectes es faran en algun dels tres formats que s’han comentat anteriorment en aquest tema: QBE, Native Query o SODA, i que seran analitzats més endavant.\nCom a exemple bàsic, consideri que podria tractar-se d’una sentència tant senzilla com:\nList&lt;Employee&gt; emps = db.queryByExample(Employee.class);\nAquest cas simplement és tota la llista de treballadors.\nQuan a la resta d’operacions (CRUD), tingui present les següents crides:\n\n\n\nAcció\nCrida\n\n\n\n\nCrear un objecte nou a la base de dades\ndb.store(objecte);\n\n\nActualitzar un objecte existent\ndb.store(objecte);\n\n\nEliminar un objecte existent\ndb.delete(objecte);\n\n\n\nObservi que el mètode store() serveix tant per inserir un objecte nou com per actualitzar un d’existent.\nAixò sí, vigili quan programi amb db4o, perquè s’han de complir els següents requeriments:\n\nSi l’objecte és nou i volem afegir-lo, utilitzem store().\nSi l’objecte ja existia i l’havíem portat anteriorment amb alguna consulta, amb store() actualitzarem l’objecte de la base de dades.\nSi l’objecte ja existia però no l’havíem inclós en cap consulta anterior, amb store() aquell objecte tornarà a inserir-se a la base de dades.\nSi volem eliminar un objecte existent, abans l’haurem de portar amb alguna consulta i aleshores podrem executar delete().\n\nCom veu, excepte en el cas d’inserir un nou objecte, les manipulacions d’objectes existents passen per que abans hagi estat inclòs en una consulta de selecció.\nA més, db4o ens ofereix control de transaccions mitjançant les crides:\ndb.commit();\ndb.rollback();\nQuan es connecta amb una base de dades s’inicia automàticament una transacció, que tancarem amb una de les dues funcions esmentades. Quan es criden, aquestes funcions inicien automàticament una nova transacció.",
    "crumbs": [
      "Inici",
      "7 db4o+Java"
    ]
  },
  {
    "objectID": "posts/2013-07-02-BD07-oodbms-amb-db4o-i-java/index.html#introducció",
    "href": "posts/2013-07-02-BD07-oodbms-amb-db4o-i-java/index.html#introducció",
    "title": "OODBMS amb db4o i Java",
    "section": "",
    "text": "Un altre element que veurem en aquest curs és el de les bases de dades orientades a objectes. Aquestes bases de dades treballen directament sobre objectes que són portats directament entre l’aplicació i la base de dades.\nLa diferència amb el model tradicional amb mapatge objecte-relacional (o el cas de les bases de dades objecte-relacionals), és que ara l’objecte es desa tal qual a la base de dades.\nEn realitat, això no és exactament així, cada producte de base de dades orientada a objectes cobrirà aquesta funcionalitat amb algun format binari propietari o treballarà sobre la serialització dels objectes a emmagatzemar.\nEn el nostre cas treballarem amb db4o, un producte senzill, petit i portable que demostra una bona eficiència i rendiment i que emmagatzema els objectes en un arxiu de disc que serà la base de dades.\nL’avantatge d’aquest producte és que és lliure, consisteix en uns arxius JAR que podem afegir als nostres projectes, i que presenta una col·lecció de funcions reduïda i útil per a realitzar les operacions CRUD bàsiques sobre els objectes que ha de manegar, a més d’oferir-nos tres mecanismes de consulta avançats:\n\nQBE (Query By Example): Consultes descrites en termes d’allò que s’espera obtenir.\nNative Query: Consultes utilitzant comparacions en els mateixos objectes.\nSODA: Consultes en llenguatge natiu de db4o.\n\nMés endavant s’estudiaran aquests casos. Ara vegem els elements bàsics en la programació d’una aplicació basada en db4o.\n\n\n\n\n\n\nNota\n\n\n\nPer a la realització d’aquests apunts s’ha treballat sobre db4o en la seva versió 8.0.\n\n\n\n\nEn primer lloc, l’aplicació haurà de disposar de les llibreries necessàries per a la seva completa operativa. Això implica els següents arxius:\nant.jar\nbloat-1.0.jar\ndb4o-8.0.249.16098-all-java5.jar\ndb4o-8.0.249.16098-bench.jar\ndb4o-8.0.249.16098-core-java5.jar\ndb4o-8.0.249.16098-cs-java5.jar\ndb4o-8.0.249.16098-cs.optional-java5.jar\ndb4o-8.0.249.16098-db4ounit-java5.jar\ndb4o-8.0.249.16098-instrumentation-java5.jar\ndb4o-8.0.249.16098-nqopt-java5.jar\ndb4o-8.0.249.16098-optional-java5.jar\ndb4o-8.0.249.16098-osgi-java5.jar\ndb4o-8.0.249.16098-osgi-test-java5.jar\ndb4o-8.0.249.16098-taj-java5.jar\ndb4o-8.0.249.16098-tools-java5.jar\nAra, una vegada disposem d’aquestes llibreries en el lloc adient, el nostre programa podrà utilitzar les funcionalitats de db4o per afegir persistència d’objectes.\nPer connectar amb una base de dades existent (o crear-ne una de nova si no existia abans), només caldrà fer una crida com la següent:\nObjectContainer db = Db4oEmbedded.openFile(\n                        Db4oEmbedded.newConfiguration(), \n                        dbFile);\non dbFile representa un String amb el nom de l’arxiu on estigui (o vulgui crear-se) la base de dades d’objectes.\nQuan hem acabat de fer les accions que siguin oportunes amb la base de dades, hem de tancar la base de dades mitjançant una simple crida com la següent:\ndb.close();\nD’aquesta manera s’alliberaran tots els recursos que db4o hagi ocupat per mantenir la base de dades activa i connectada, a més de buidar al disc les últimes modificacions pendents de ser fixades.\n\n\n\nQuant a l’execució de consultes, les de selecció d’objectes es faran en algun dels tres formats que s’han comentat anteriorment en aquest tema: QBE, Native Query o SODA, i que seran analitzats més endavant.\nCom a exemple bàsic, consideri que podria tractar-se d’una sentència tant senzilla com:\nList&lt;Employee&gt; emps = db.queryByExample(Employee.class);\nAquest cas simplement és tota la llista de treballadors.\nQuan a la resta d’operacions (CRUD), tingui present les següents crides:\n\n\n\nAcció\nCrida\n\n\n\n\nCrear un objecte nou a la base de dades\ndb.store(objecte);\n\n\nActualitzar un objecte existent\ndb.store(objecte);\n\n\nEliminar un objecte existent\ndb.delete(objecte);\n\n\n\nObservi que el mètode store() serveix tant per inserir un objecte nou com per actualitzar un d’existent.\nAixò sí, vigili quan programi amb db4o, perquè s’han de complir els següents requeriments:\n\nSi l’objecte és nou i volem afegir-lo, utilitzem store().\nSi l’objecte ja existia i l’havíem portat anteriorment amb alguna consulta, amb store() actualitzarem l’objecte de la base de dades.\nSi l’objecte ja existia però no l’havíem inclós en cap consulta anterior, amb store() aquell objecte tornarà a inserir-se a la base de dades.\nSi volem eliminar un objecte existent, abans l’haurem de portar amb alguna consulta i aleshores podrem executar delete().\n\nCom veu, excepte en el cas d’inserir un nou objecte, les manipulacions d’objectes existents passen per que abans hagi estat inclòs en una consulta de selecció.\nA més, db4o ens ofereix control de transaccions mitjançant les crides:\ndb.commit();\ndb.rollback();\nQuan es connecta amb una base de dades s’inicia automàticament una transacció, que tancarem amb una de les dues funcions esmentades. Quan es criden, aquestes funcions inicien automàticament una nova transacció.",
    "crumbs": [
      "Inici",
      "7 db4o+Java"
    ]
  },
  {
    "objectID": "posts/2013-07-02-BD07-oodbms-amb-db4o-i-java/index.html#llenguatge-de-consultes-en-db4o",
    "href": "posts/2013-07-02-BD07-oodbms-amb-db4o-i-java/index.html#llenguatge-de-consultes-en-db4o",
    "title": "OODBMS amb db4o i Java",
    "section": "2. LLenguatge de consultes en db4o",
    "text": "2. LLenguatge de consultes en db4o\nCom s’ha dit, db4o ens ofereix 3 formes d’escriure consultes de selecció d’objectes.\n\n2.1. QBE (Query By Example)\nAquesta modalitat de consultes es fonamenta en explicar-li a db4o com volem que sigui el resultat obtingut. Dit d’una altra manera, passem a la consulta un objecte amb els camps assignats de manera que donin a entendre quins valors estem condicionant.\nEl cas més senzill és una consulta no filtrada, que pren la següent forma:\nList&lt;Department&gt; depts = db.queryByExample(Department.class);\nCom veu, l’exemple és passar la classe del resultat que busquem, és a dir, tots els objectes Department (de la seva classe).\nSi el que volem és filtrar per algun criteri, haurem de subministrar un objecte parcialment assignat que demostri la nostra intenció:\nDepartment d = new Department();\nd.setDepartmentName(\"Sales\");\nList&lt;Department&gt; depts = db.queryByExample(d);\nEn aquest cas s’ha configurat un Department que només té assignat un camp, que és el nom del departament. Això farà que, en cercar els departaments, realitzi un filtrat d’igualtat amb el valor indicat només en aquest camp.\nCom veu, les consultes QBE són útils en casos molt bàsics, i no permetran filtrar rangs de valors o expressions avaluades més complexes.\n\n\n2.2. Native Query\nEl software db4o ens ofereix un mecanisme força interessant per filtrar objectes amb aquest sistema anomenat Native Query.\nLa idea és senzilla: Estem treballant amb objectes, en un llenguatge de programació orientat a objectes, on la comprovació d’un filtratge “passa/no passa” pot ser tant senzilla com una condició if ben escrita.\nAixí doncs, no seria més pràctic deixar al programador escriure la funció de filtrat “passa/no passa” en el seu llenguatge d’alt nivell orientat a objectes? Native Query fa exactament això.\nUn exemple: Suposem que volem tots els treballadors que cobrin un sou superior a 10000 o que treballin per al departament anomenat “Sales”. Amb Native Query quedarà així:\nList&lt;Employee&gt; emps = db.query(new Predicate&lt;Employee&gt;() {\n    public boolean match(Employee emp) {\n    return ( \n        (emp.getSalary() &gt; 10000) || \n        (emp.getDepartment().getDepartmentName().equals(\"Sales\")) \n    );\n    }\n});\nÉs a dir, la consulta es basa en un Predicate sobre la classe Employee que passarà cadascun dels Employee trobats a la base de dades per la funció interna que hi és definida. Si l’objecte concret aplicat a match() passa la condició i retorna un true, aquell objecte sortirà al resultat de la consulta. Si per a l’objecte, la funció match() hagués retornat un false, aleshores serà eliminat del resultat.\nAquest mecanisme ens permet, amb molta facilitat, utilitzar tota la infraestructura de funcions i classes del llenguatge de programació i podrem realitzar qualsevol tasca que ens puguem imaginar o plantejar.\n\n\n2.3. SODA\nSODA és el mecanisme intern de db4o per executar consultes sobre les seves bases de dades. És, per tant, el llenguatge més eficient i que permet afinar més la consulta que s’executarà sobre la base de dades.\nEn el cas SODA, les consultes s’inicien afegint una restricció que indica quina és la classe buscada en la base de dades, i després s’afegeixen filtres addicionals que condicionen els objectes obtinguts com a resultat.\nObservi el següent exemple:\nQuery query=db.query();\nquery.constrain(Employee.class);\nquery.descend(\"lastname\").constrain(\"King\");\nList&lt;Employee&gt; result = query.execute();\nVeurà que s’ha utilitzat el mètode descend() per baixar a aquell atribut de l’objecte i aplicar un criteri restrictiu. En aquest cas, obtindrem els treballadors amb cognom “King”.\nPodem aplicar restriccions d’aquest tipus sobre qualsevol tipus de dada:\nQuery query=db.query();\nquery.constrain(Department.class);\nquery.descend(\"locationId\").constrain(1700);\nList&lt;Department&gt; result = query.execute();\nI aplicar modificadors que alteren el sentit de la restricció:\nQuery query=db.query();\nquery.constrain(Department.class);\nquery.descend(\"locationId\").constrain(1700).not();\nList&lt;Department&gt; result = query.execute();\nA més, podrem combinar diversos descend() i construir consultes de selecció realment complexes:\nQuery query=db.query();\nquery.constrain(Employee.class);\nquery.descend(\"lastname\").constrain(\"King\")\n    .or(query.descend(\"salary\").constrain(13000).greater());\nquery.descend(\"salary\").orderDescending();\nList&lt;Employee&gt; result = query.execute();\nObservi com s’ha afegit ordenació del resultat de la consulta en aquest últim exemple.",
    "crumbs": [
      "Inici",
      "7 db4o+Java"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "flx.cat",
    "section": "",
    "text": "Ordena per\n      Defecte\n      \n        Títol\n      \n      \n        Data - Més antic\n      \n      \n        Data - Més nou\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nArguments i modificadors en shell-scripts\n\n\n\n\n\nRecull de bones pràctiques en la construcció de shell-scripts amb uns exemples d’ús on es volen arguments, modificadors amb i sense arguments, així com variants de modificadors amb nom llarg i nom curt. Es tracta d’un punt de partida en la construcció de shell scripts de qualitat.\n\n\n\n\n\n1 d’abr. 2021\n\n6 min\n\n\n\n\n\n\n\n\n\n\n\nBucles en un sed\n\n\n\n\n\nExperiència interessant amb sed on descobreixo que els bucles sí que són permesos i com usar-los\n\n\n\n\n\n4 de des. 2013\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\nGuia ràpida de Git\n\n\n\n\n\nFuncionalitats bàsiques de Git explicats i demostrats amb exemples senzills\n\n\n\n\n\n11 de nov. 2013\n\n22 min\n\n\n\n\n\n\n\n\n\n\n\nLiquid-LaTeX Jekyll Plugin\n\n\n\n\n\nAnother Jekyll plugin. This one renders and inserts arbitrary LaTeX content on your posts\n\n\n\n\n\n10 de nov. 2013\n\n6 min\n\n\n\n\n\n\n\n\n\n\n\nLiquid-Lipsum Jekyll Plugin\n\n\n\n\n\nMy first Jekyll plugin. It inserts random text inside your posts\n\n\n\n\n\n9 de nov. 2013\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\nXND, BaseX i Java\n\n\n\n\n\nDarrera part del curs Curs BBDD i Java centrada en la connexió de Java amb un sistema de bases de dades natives XND. En concret, s’estudiarà la connexió BaseX - Java a través de diferents mètodes de connexió.\n\n\n\n\n\n3 de jul. 2013\n\n25 min\n\n\n\n\n\n\n\n\n\n\n\nXND - XPath i XQuery\n\n\n\n\n\nPenúltima part del curs Curs BBDD i Java centrada en la construcció de consultes mitjançant XPath/XQuery.\n\n\n\n\n\n3 de jul. 2013\n\n28 min\n\n\n\n\n\n\n\n\n\n\n\nOODBMS amb db4o i Java\n\n\n\n\n\nSetena part del curs Curs BBDD i Java centrada la programació d’aplicacions que utilitzin una base de dades orientada a objectes com db4o per a poder emmagatzemar objectes directament en un magatzem especialitzat d’objectes.\n\n\n\n\n\n2 de jul. 2013\n\n7 min\n\n\n\n\n\n\n\n\n\n\n\nHibernate i JPA\n\n\n\n\n\nSisena part del curs Curs BBDD i Java centrada en la millora de les tècniques presentades en el punt anterior. En concret s’estudia el component de Java de persistència JPA i com podem combinar-lo amb tècniques vistes fins ara.\n\n\n\n\n\n1 de jul. 2013\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\nHibernate i el mapatge objecte-relacional\n\n\n\n\n\nCinquena part del curs Curs BBDD i Java on s’analitzarà com realitzar mapatge objecte-relacional entre objectes d’un llenguatge orientat a objectes d’alt nivell (Java) amb bases de dades relacionals tradicionals i les tècniques associades per a l’extracció i inserció de dades en aquests casos.\n\n\n\n\n\n1 de jul. 2013\n\n19 min\n\n\n\n\n\n\n\n\n\n\n\nJDBC amb SQL\n\n\n\n\n\nSegona part del curs Curs BBDD i Java centrada en la connexió d’un llenguatge d’alt nivell com Java amb un motor de bases de dades a través de connectors JDBC per a l’extracció i inserció de dades en bases de dades relacionals i amb l’execució de sentències SQL tradicionals.\n\n\n\n\n\n29 de juny 2013\n\n17 min\n\n\n\n\n\n\n\n\n\n\n\nTipus de bases de dades - discusió i ús\n\n\n\n\n\nPrimera part del curs Curs BBDD i Java on analitzem les diferents formes d’emmagatzemar dades i com fer-les disponible per als programes que desenvolupem amb llenguatges d’alt nivell.\n\n\n\n\n\n29 de juny 2013\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\nORDBMS amb Oracle\n\n\n\n\n\nTercera part del curs Curs BBDD i Java centrada en l’anàlisi de la programació de bases de dades objecte-relacionals amb Oracle.\n\n\n\n\n\n29 de juny 2013\n\n1 min\n\n\n\n\n\n\n\n\n\n\n\nXML i Java amb StaX i JAXB\n\n\n\n\n\nQuarta part del curs Curs BBDD i Java centrada en el mapatge d’arxius XML amb objectes de Java. Aquesta tècnica minimitza la separació entre el magatzem de dades i el llenguatge d’alt nivell, fent que la informació s’integri millor en el cicle de vida de l’aplicació.\n\n\n\n\n\n29 de juny 2013\n\n16 min\n\n\n\n\n\n\n\n\n\n\n\nCurs BBDD i Java (índex)\n\n\n\n\n\nPàgina principal del curs Curs BBDD i Java que vaig impartir a professors del centre d’estudis Stucom en el marc de formació interna del professorat. L’objectiu d’aquest curs és adquirir coneixements en tècniques avançades de programació Java per a la l’accés a dades en magatzems d’informació diversos.\n\n\n\n\n\n10 de maig 2013\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\nCreating a new Grub2 background image (menu only) in Ubuntu &gt;11.10\n\n\n\n\n\nThis little post explains how to configure a background image to the Grub boot menu used in many Linux distributions.\n\n\n\n\n\n22 d’abr. 2013\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\nOracle SQL és fàcil!\n\n\n\n\n\nDetalls del meu llibre sobre Oracle SQL publicat amb Bubok\n\n\n\n\n\n19 de jul. 2012\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\nFormat Intel HEX\n\n\n\n\n\nEn aquest article es parla sobre el format Intel Hex, que és l’utilitzat pels compiladors i assembladors que treballen sobre dispositius de memòria (inclosa la memòria Flash dels PIC, per exemple).\n\n\n\n\n\n17 de nov. 2010\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\nElements de sortida electrònics (I)\n\n\n\n\n\nEs tracten els diferents elements disponibles per a realitzar la sortida de dades en un circuit electrònic. S’estudien els LEDs (amb i sense transistor), el relé, i multitud d’elements LED en diferents estructures.\n\n\n\n\n\n22 d’oct. 2010\n\n25 min\n\n\n\n\nCap element coincident"
  }
]